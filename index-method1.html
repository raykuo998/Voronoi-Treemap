<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programming Skills Map - Method 1 (Dynamic Geometry)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            color: rgba(255, 255, 255, 0.9);
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.1rem;
        }

        .method-badge {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            display: inline-block;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            display: none;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .people-panel {
            background: white;
            padding: 16px 18px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            margin-bottom: 16px;
            display: none;
        }

        .people-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .people-search {
            flex: 1 1 240px;
            max-width: 420px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .people-search input[type="text"] {
            width: 100%;
            padding: 9px 10px;
            border-radius: 10px;
            border: 1px solid rgba(0, 0, 0, 0.12);
            outline: none;
            font-size: 13px;
            font-weight: 600;
            color: #333;
            background: rgba(0, 0, 0, 0.02);
        }

        .people-search input[type="text"]:focus {
            border-color: rgba(102, 126, 234, 0.7);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.15);
            background: white;
        }

        .people-panel-title {
            font-weight: 800;
            color: #333;
            font-size: 14px;
            letter-spacing: 0.02em;
        }

        .people-panel-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .people-panel-actions button {
            padding: 8px 12px;
            font-size: 13px;
        }

        .people-count {
            color: #666;
            font-size: 13px;
            font-weight: 600;
        }

        .people-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 360px;
            overflow: auto;
            padding-right: 6px;
        }

        .person-item {
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            padding: 12px 16px;
            border-radius: 10px;
            border: 1px solid rgba(0, 0, 0, 0.08);
            background: #fff;
            transition: background 150ms ease;
        }

        .person-item:hover {
            background: rgba(102, 126, 234, 0.06);
        }

        .person-checkbox {
            width: 18px;
            height: 18px;
            flex: 0 0 auto;
            cursor: pointer;
        }

        .person-avatar,
        .person-avatar-fallback {
            width: 28px;
            height: 28px;
            border-radius: 999px;
            flex: 0 0 auto;
        }

        .person-avatar {
            object-fit: cover;
            background: rgba(0, 0, 0, 0.05);
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.08);
        }

        .person-avatar-fallback {
            display: grid;
            place-items: center;
            font-size: 11px;
            font-weight: 800;
            letter-spacing: 0.04em;
            color: rgba(0, 0, 0, 0.65);
            background: rgba(102, 126, 234, 0.12);
            border: 1px solid rgba(0, 0, 0, 0.06);
        }

        .person-name {
            min-width: 0;
            flex: 1 1 auto;
            font-size: 14px;
            font-weight: 500;
            color: #333;
        }

        .person-details-btn {
            flex: 0 0 auto;
            padding: 6px 10px;
            font-size: 12px;
            font-weight: 700;
            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            background: rgba(102, 126, 234, 0.08);
            color: #3344aa;
            cursor: pointer;
        }

        .person-details-btn:hover {
            background: rgba(102, 126, 234, 0.14);
        }

        body.people-details-open {
            overflow: hidden;
        }

        .people-details-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.38);
            display: none;
            align-items: stretch;
            justify-content: flex-end;
            z-index: 1000;
        }

        .people-details-backdrop[data-open="1"] {
            display: flex;
        }

        .people-details-drawer {
            width: min(560px, 94vw);
            height: 100%;
            background: #fff;
            box-shadow: -12px 0 30px rgba(0, 0, 0, 0.18);
            display: flex;
            flex-direction: column;
        }

        .people-details-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 14px 16px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        .people-details-title {
            font-weight: 900;
            color: #333;
            font-size: 14px;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .people-details-close {
            flex: 0 0 auto;
            width: 34px;
            height: 34px;
            border-radius: 10px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            background: rgba(0, 0, 0, 0.03);
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            color: #444;
        }

        .people-details-close:hover {
            background: rgba(0, 0, 0, 0.06);
        }

        .people-details-body {
            padding: 14px 16px;
            overflow: auto;
        }

        .person-section {
            display: grid;
            gap: 8px;
        }

        .person-section + .person-section {
            margin-top: 14px;
        }

        .person-section-title {
            color: #667eea;
            font-weight: 900;
            font-size: 12px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .person-skill-list,
        .person-reco-list {
            display: grid;
            gap: 8px;
        }

        .person-skill-row,
        .person-reco-row {
            padding: 10px 10px;
            border-radius: 10px;
            border: 1px solid rgba(0, 0, 0, 0.06);
            background: rgba(102, 126, 234, 0.04);
        }

        .person-skill-row {
            display: grid;
            grid-template-columns: 1fr auto;
            grid-template-rows: auto auto;
            gap: 6px 12px;
        }

        .person-reco-row {
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: auto auto auto;
            gap: 8px;
        }

        .person-reco-bar {
            height: 8px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.08);
            overflow: hidden;
        }

        .person-reco-bar-fill {
            height: 100%;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.35), rgba(102, 126, 234, 0.95));
        }

        .person-reco-reason {
            white-space: pre-line;
            font-size: 12px;
            font-weight: 700;
            line-height: 1.35;
            color: rgba(0, 0, 0, 0.55);
            background: rgba(0, 0, 0, 0.02);
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 10px;
            padding: 10px 10px;
        }

        .person-skill-main {
            min-width: 0;
        }

        .person-skill-name,
        .person-reco-name {
            font-weight: 900;
            color: #333;
            font-size: 13px;
            line-height: 1.2;
        }

        .person-skill-sub,
        .person-reco-sub {
            margin-top: 2px;
            color: rgba(0, 0, 0, 0.55);
            font-weight: 700;
            font-size: 12px;
            line-height: 1.2;
        }

        .person-skill-stat {
            font-variant-numeric: tabular-nums;
            font-weight: 900;
            color: #333;
            font-size: 12px;
            white-space: nowrap;
        }

        .person-skill-bar {
            grid-column: 1 / -1;
            height: 8px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.08);
            overflow: hidden;
        }

        .person-skill-bar-fill {
            height: 100%;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.35), rgba(102, 126, 234, 0.95));
        }

        .person-empty {
            color: #666;
            font-size: 13px;
            line-height: 1.4;
            padding: 2px 2px;
        }

        button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.6);
        }

        button:active {
            transform: translateY(0);
        }

        .back-btn {
            background: #6c757d;
        }

        .back-btn:hover {
            background: #5a6268;
        }

        .breadcrumb {
            color: #333;
            font-size: 14px;
            font-weight: 500;
        }

        .chart-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            padding: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .toplists {
            margin-top: 14px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .toplist-card {
            background: rgba(255, 255, 255, 0.92);
            border: 1px solid rgba(0, 0, 0, 0.06);
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
            padding: 14px 16px;
        }

        .toplist-title {
            text-align: center;
            color: #667eea;
            font-weight: 800;
            font-size: 12px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .toplist-list {
            list-style: none;
            padding-left: 0;
            margin: 0;
            display: grid;
            gap: 8px;
        }

        .toplist-item {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 10px;
            padding: 8px 10px;
            border-radius: 10px;
            background: rgba(102, 126, 234, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.04);
        }

        .toplist-skill {
            font-weight: 800;
            color: #333;
            font-size: 13px;
            line-height: 1.2;
        }

        .toplist-domain {
            display: block;
            margin-top: 2px;
            color: rgba(0, 0, 0, 0.55);
            font-weight: 700;
            font-size: 12px;
        }

        .toplist-stat {
            font-variant-numeric: tabular-nums;
            color: #333;
            font-weight: 800;
            font-size: 12px;
            white-space: nowrap;
        }

        .toplist-empty {
            color: #666;
            font-size: 13px;
            line-height: 1.5;
            text-align: center;
            padding: 10px 6px;
        }

        .tooltip {
            position: fixed;
            display: none;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            pointer-events: none;
            z-index: 1000;
            max-width: 280px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            line-height: 1.6;
            backdrop-filter: blur(10px);
        }

        .tooltip strong {
            display: block;
            margin-bottom: 6px;
            font-size: 15px;
            color: #fff;
        }

        /* Legend (copied from index.html, positioned bottom-right) */
        .legend-card {
            background: rgba(255, 255, 255, 0.92);
            border: 1px solid rgba(0, 0, 0, 0.06);
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
            padding: 14px 16px;
            margin-top: 12px;
        }

        .legend-card.legend-floating {
            position: absolute;
            right: 16px;
            bottom: 16px;
            margin-top: 0;
            z-index: 5;
            max-width: min(520px, calc(100% - 32px));
            pointer-events: none;
            background: transparent;
            border: none;
            box-shadow: none;
            padding: 0;
        }

        .legend-title {
            text-align: center;
            color: #667eea;
            font-weight: 800;
            font-size: 12px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .legend-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        /* For floating legend: stack items and align right */
        .legend-card.legend-floating .legend-row {
            flex-direction: column;
            align-items: flex-end;
            justify-content: flex-end;
            gap: 10px;
            flex-wrap: nowrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 260px;
        }

        .legend-card.legend-floating .legend-item {
            min-width: 0;
            justify-content: flex-end;
        }

        .legend-text {
            text-align: right;
        }

        .legend-divider {
            width: 1px;
            height: 36px;
            background: rgba(0, 0, 0, 0.08);
        }

        .legend-icon-size {
            display: flex;
            align-items: flex-end;
            gap: 8px;
        }

        .legend-dot {
            display: inline-block;
            border-radius: 999px;
            background: #667eea;
            opacity: 0.75;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.8);
        }

        .legend-dot.dot-sm {
            width: 10px;
            height: 10px;
        }

        .legend-dot.dot-lg {
            width: 18px;
            height: 18px;
        }

        .legend-icon-gradient {
            width: 96px;
            height: 14px;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.18), rgba(102, 126, 234, 0.95));
            border: 1px solid rgba(0, 0, 0, 0.08);
        }

        .legend-label {
            font-weight: 800;
            color: #333;
            font-size: 13px;
            line-height: 1.1;
        }

        .legend-desc {
            color: #666;
            font-size: 13px;
            line-height: 1.35;
            margin-top: 2px;
        }

        .legend-sub {
            text-align: center;
            color: rgba(0, 0, 0, 0.55);
            font-size: 12px;
            margin-top: 10px;
            line-height: 1.4;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .toplists {
                grid-template-columns: 1fr;
            }

            button {
                width: 100%;
            }

            .legend-card.legend-floating {
                right: 12px;
                bottom: 12px;
                max-width: calc(100% - 24px);
            }

            .legend-item {
                min-width: 220px;
            }

            .legend-card.legend-floating .legend-item {
                min-width: 0;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1 id="mainTitle">Programming Skills Map</h1>
        <p class="subtitle" id="subtitle">Method 1: dynamic geometry (areas recomputed per selection)</p>
        <div style="text-align: center;">
            <span class="method-badge">Method 1 (Dynamic): area = sum of selected unlocked sub-skills</span>
        </div>

        <div class="controls" id="controls">
            <button class="back-btn" id="backBtn" onclick="goBack()">← Back</button>
            <button id="resetBtn" onclick="reset()">⌂ Reset to Overview</button>
            <span class="breadcrumb" id="breadcrumb"></span>
        </div>

        <div class="chart-container">
            <svg id="chart"></svg>
            <div class="legend-card legend-floating" aria-label="Legend">
                <div class="legend-row">
                    <div class="legend-item">
                        <div class="legend-icon-size" aria-hidden="true">
                            <span class="legend-dot dot-sm"></span>
                            <span class="legend-dot dot-lg"></span>
                        </div>
                        <div class="legend-text">
                            <div class="legend-label">Size</div>
                            <div class="legend-desc">How well I know this skill</div>
                        </div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-icon-gradient" aria-hidden="true"></div>
                        <div class="legend-text">
                            <div class="legend-label">Color intensity</div>
                            <div class="legend-desc">How frequent (proficient) I use this skill</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="toplists" id="toplists">
            <div class="toplist-card">
                <div class="toplist-title">Top 5 Most proficient skills</div>
                <ul class="toplist-list" id="topMostList"></ul>
                <div class="toplist-empty" id="topMostEmpty" style="display:none;"></div>
            </div>
            <div class="toplist-card">
                <div class="toplist-title">Top 5 Least proficient skills</div>
                <ul class="toplist-list" id="topLeastList"></ul>
                <div class="toplist-empty" id="topLeastEmpty" style="display:none;"></div>
            </div>
        </div>

        <div class="people-panel" id="peoplePanel">
            <div class="people-panel-header">
                <div class="people-panel-title">People</div>
                <div class="people-search">
                    <input type="text" id="peopleSearch" placeholder="Search people..." />
                </div>
                <div class="people-panel-actions">
                    <span class="people-count" id="peopleCount"></span>
                    <button type="button" id="selectAllPeopleBtn">Select all</button>
                    <button type="button" class="back-btn" id="clearPeopleBtn">Clear</button>
                </div>
            </div>
            <div class="people-list" id="peopleList"></div>
        </div>

        <div class="people-details-backdrop" id="peopleDetailsBackdrop" data-open="0" aria-hidden="true">
            <div class="people-details-drawer" role="dialog" aria-modal="true" aria-labelledby="peopleDetailsTitle">
                <div class="people-details-header">
                    <div class="people-details-title" id="peopleDetailsTitle">Details</div>
                    <button type="button" class="people-details-close" id="peopleDetailsCloseBtn"
                        aria-label="Close details">×</button>
                </div>
                <div class="people-details-body" id="peopleDetailsBody"></div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-weighted-voronoi@1"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-voronoi-map@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-voronoi-treemap@1"></script>
    <script>
        if (typeof d3 === 'undefined') {
            document.body.innerHTML = '<div style="text-align:center;padding:50px;"><h2>⚠️ D3.js Failed to Load</h2><p>Please check your internet connection</p></div>';
            throw new Error('D3.js failed to load');
        }
    </script>

    <script>
        const cloneObject = typeof structuredClone === 'function'
            ? structuredClone
            : (obj) => JSON.parse(JSON.stringify(obj));

        // Global variables
        let baseTaxonomy = null; // loaded from index.html
        let taxonomyData = null;
        let currentData = null;
        let history = [];
        const width = 1000;
        const height = 1000;
        const radius = Math.min(width, height) / 2 - 80;

        // Multi-person state (method 1: dynamic geometry, recompute Voronoi per selection)
        let peopleData = null;
        let selectedPersonIds = new Set();
        let skillKeyToMeta = new Map(); // skillKey -> { domainName, skillName, subSkillNames:Set<string> }
        let personIdToSkillMetrics = new Map(); // personId -> Map(skillKey -> { usage:number, unlockedCount:number })
        let usageTGlobal = () => 0.6; // (usage:number) -> t in [0,1]
        let selectionAggBySkillKey = new Map(); // skillKey -> { usageSum, unlockedSum, unlockedPeopleCount }
        let selectionAggSelectedCount = 0;
        let teamSkillStatsBySkillKey = new Map(); // skillKey -> { haveRatio, usageAvg, haveCount, totalPeople }
        let renderDebounceTimer = null;

        // Domain color schemes
        const domainColorSchemes = {
            'Frontend': d3.interpolateBlues,
            'Backend': d3.interpolateGreens,
            'DevOps': d3.interpolateOranges,
            'Mobile': d3.interpolatePurples
        };

        function makeSkillKey(domainName, skillName) {
            return `${domainName}::${skillName}`;
        }

        function isPeopleModeEnabled() {
            return Array.isArray(peopleData?.people) && peopleData.people.length > 0;
        }

        function positionTooltip(event, tooltip) {
            if (!tooltip) return;
            const offset = 12;
            const pad = 8;

            const clientX = Number(event?.clientX);
            const clientY = Number(event?.clientY);
            const x0 = Number.isFinite(clientX) ? clientX : 0;
            const y0 = Number.isFinite(clientY) ? clientY : 0;

            const rect = tooltip.getBoundingClientRect();

            let x = x0 + offset;
            let y = y0 + offset;

            if (x + rect.width + pad > window.innerWidth) x = x0 - rect.width - offset;
            if (y + rect.height + pad > window.innerHeight) y = y0 - rect.height - offset;

            x = Math.max(pad, Math.min(window.innerWidth - rect.width - pad, x));
            y = Math.max(pad, Math.min(window.innerHeight - rect.height - pad, y));

            tooltip.style.left = Math.round(x) + 'px';
            tooltip.style.top = Math.round(y) + 'px';
        }

        function createCirclePolygon(r, points = 64) {
            const circlePolygon = [];
            for (let i = 0; i < points; i++) {
                const angle = (i / points) * 2 * Math.PI;
                circlePolygon.push([Math.cos(angle) * r, Math.sin(angle) * r]);
            }
            return circlePolygon;
        }

        function getSubSkillCounts(skill) {
            const subSkills = Array.isArray(skill?.subSkills) ? skill.subSkills : [];
            const total = subSkills.length;
            const unlocked = subSkills.reduce((acc, s) => acc + (s && s.unlocked ? 1 : 0), 0);
            return { unlocked, total };
        }

        function getUsageValue(skill) {
            const usage = Number(skill?.usage);
            return Number.isFinite(usage) ? usage : 0;
        }

        function createGlobalUsageIntensityScaleFromValues(values) {
            const numeric = (Array.isArray(values) ? values : [])
                .map(v => Number(v))
                .filter(v => Number.isFinite(v));
            const extent = d3.extent(numeric);
            const hasRange =
                Number.isFinite(extent[0]) &&
                Number.isFinite(extent[1]) &&
                extent[0] !== extent[1];
            return hasRange
                ? d3.scaleLinear().domain(extent).range([0.15, 0.95]).clamp(true)
                : () => 0.6;
        }

        function ensureDomainNode(taxonomy, domainName) {
            if (!taxonomy) return null;
            if (!Array.isArray(taxonomy.children)) taxonomy.children = [];
            const existing = taxonomy.children.find(d => d && d.name === domainName) || null;
            if (existing) return existing;
            const domainNode = { name: domainName, children: [] };
            taxonomy.children.push(domainNode);
            return domainNode;
        }

        function ensureSkillNode(domainNode, skillName) {
            if (!domainNode) return null;
            if (!Array.isArray(domainNode.children)) domainNode.children = [];
            const existing = domainNode.children.find(s => s && s.name === skillName) || null;
            if (existing) return existing;
            const skillNode = { name: skillName, usage: 0, subSkills: [] };
            domainNode.children.push(skillNode);
            return skillNode;
        }

        function ensureSubSkillNames(skillNode, names) {
            if (!skillNode) return;
            if (!Array.isArray(skillNode.subSkills)) skillNode.subSkills = [];
            const existing = new Set(skillNode.subSkills.map(s => s && s.name).filter(Boolean));
            (Array.isArray(names) ? names : []).forEach(name => {
                if (!name || existing.has(name)) return;
                skillNode.subSkills.push({ name, unlocked: false });
                existing.add(name);
            });
        }

        function applyPeopleUnionToTaxonomy(taxonomy, people) {
            const persons = Array.isArray(people) ? people : [];
            persons.forEach(person => {
                const skills = Array.isArray(person?.skills) ? person.skills : [];
                skills.forEach(rec => {
                    const domainName = String(rec?.domain || '').trim();
                    const skillName = String(rec?.skill || '').trim();
                    if (!domainName || !skillName) return;
                    const domainNode = ensureDomainNode(taxonomy, domainName);
                    const skillNode = ensureSkillNode(domainNode, skillName);
                    ensureSubSkillNames(skillNode, rec?.unlockedSubSkills);
                });
            });
        }

        function annotateAndIndexTaxonomy(taxonomy) {
            skillKeyToMeta = new Map();
            const domains = Array.isArray(taxonomy?.children) ? taxonomy.children : [];
            domains.forEach(domain => {
                const domainName = domain?.name;
                const skills = Array.isArray(domain?.children) ? domain.children : [];
                skills.forEach(skill => {
                    if (!skill || !domainName || !skill.name) return;
                    skill.__domain = domainName;
                    skill.__skillKey = makeSkillKey(domainName, skill.name);
                    const subSkillNames = new Set(
                        (Array.isArray(skill.subSkills) ? skill.subSkills : [])
                            .map(s => s && s.name)
                            .filter(Boolean)
                    );
                    skillKeyToMeta.set(skill.__skillKey, { domainName, skillName: skill.name, subSkillNames });
                });
            });
        }

        function buildPeopleMetrics(people) {
            personIdToSkillMetrics = new Map();
            const persons = Array.isArray(people) ? people : [];
            const usageValues = [];

            persons.forEach(person => {
                const id = String(person?.id || '').trim();
                if (!id) return;
                personIdToSkillMetrics.set(id, new Map());
                const skills = Array.isArray(person?.skills) ? person.skills : [];
                skills.forEach(rec => {
                    const domainName = String(rec?.domain || '').trim();
                    const skillName = String(rec?.skill || '').trim();
                    if (!domainName || !skillName) return;
                    const skillKey = makeSkillKey(domainName, skillName);
                    const usage = Number(rec?.usage);
                    const usageValue = Number.isFinite(usage) ? usage : 0;
                    const unlockedNames = Array.isArray(rec?.unlockedSubSkills) ? rec.unlockedSubSkills : [];

                    const meta = skillKeyToMeta.get(skillKey);
                    let unlockedCount = 0;
                    if (meta && meta.subSkillNames && meta.subSkillNames.size > 0) {
                        const seen = new Set();
                        unlockedNames.forEach(n => {
                            const name = String(n || '').trim();
                            if (!name || seen.has(name)) return;
                            if (meta.subSkillNames.has(name)) {
                                unlockedCount += 1;
                                seen.add(name);
                            }
                        });
                    } else {
                        unlockedCount = unlockedNames.length;
                    }

                    personIdToSkillMetrics.get(id).set(skillKey, { usage: usageValue, unlockedCount });
                    usageValues.push(usageValue);
                });
            });

            usageTGlobal = createGlobalUsageIntensityScaleFromValues([0, ...usageValues]);
        }

        function recomputeSelectionAggregates() {
            selectionAggSelectedCount = selectedPersonIds?.size || 0;
            selectionAggBySkillKey = new Map();
            if (!isPeopleModeEnabled()) return;

            for (const personId of selectedPersonIds) {
                const perSkill = personIdToSkillMetrics.get(personId);
                if (!perSkill) continue;
                for (const [skillKey, metric] of perSkill.entries()) {
                    const usage = Number(metric?.usage) || 0;
                    const unlocked = Number(metric?.unlockedCount) || 0;
                    if (usage === 0 && unlocked === 0) continue;

                    let agg = selectionAggBySkillKey.get(skillKey);
                    if (!agg) {
                        agg = { usageSum: 0, unlockedSum: 0, unlockedPeopleCount: 0 };
                        selectionAggBySkillKey.set(skillKey, agg);
                    }

                    agg.usageSum += usage;
                    agg.unlockedSum += unlocked;
                    if (unlocked > 0) agg.unlockedPeopleCount += 1;
                }
            }
        }

        function getSelectionMetricsForSkillKey(skillKey) {
            const selectedCount = selectionAggSelectedCount;
            const agg = selectionAggBySkillKey.get(skillKey) || { usageSum: 0, unlockedSum: 0, unlockedPeopleCount: 0 };

            if (selectedCount === 0) {
                return {
                    selectedCount: 0,
                    unlockedPeopleCount: 0,
                    unlockedPeopleRatio: 0,
                    usageAvg: 0,
                    unlockedSum: 0
                };
            }

            return {
                selectedCount,
                unlockedPeopleCount: agg.unlockedPeopleCount,
                unlockedPeopleRatio: agg.unlockedPeopleCount / selectedCount,
                usageAvg: agg.usageSum / selectedCount,
                unlockedSum: agg.unlockedSum
            };
        }

        function computeTeamSkillStats(persons) {
            const people = Array.isArray(persons) ? persons : [];
            const totalPeople = people.length;
            const haveCountBySkillKey = new Map();
            const usageSumBySkillKey = new Map();

            for (const skillKey of skillKeyToMeta.keys()) {
                haveCountBySkillKey.set(skillKey, 0);
                usageSumBySkillKey.set(skillKey, 0);
            }

            people.forEach(person => {
                const personId = String(person?.id || '').trim();
                if (!personId) return;
                const perSkill = personIdToSkillMetrics.get(personId);
                if (!perSkill) return;

                for (const [skillKey, metric] of perSkill.entries()) {
                    const usage = Number(metric?.usage) || 0;
                    const unlocked = Number(metric?.unlockedCount) || 0;
                    if (!usageSumBySkillKey.has(skillKey)) usageSumBySkillKey.set(skillKey, 0);
                    usageSumBySkillKey.set(skillKey, (usageSumBySkillKey.get(skillKey) || 0) + usage);

                    if (unlocked > 0) {
                        if (!haveCountBySkillKey.has(skillKey)) haveCountBySkillKey.set(skillKey, 0);
                        haveCountBySkillKey.set(skillKey, (haveCountBySkillKey.get(skillKey) || 0) + 1);
                    }
                }
            });

            teamSkillStatsBySkillKey = new Map();
            for (const skillKey of skillKeyToMeta.keys()) {
                const haveCount = haveCountBySkillKey.get(skillKey) || 0;
                const usageSum = usageSumBySkillKey.get(skillKey) || 0;
                teamSkillStatsBySkillKey.set(skillKey, {
                    haveCount,
                    totalPeople,
                    haveRatio: totalPeople > 0 ? haveCount / totalPeople : 0,
                    usageAvg: totalPeople > 0 ? usageSum / totalPeople : 0
                });
            }
        }

        function formatPercent01(p) {
            const n = Number(p);
            if (!Number.isFinite(n)) return '0%';
            return `${Math.round(Math.max(0, Math.min(1, n)) * 100)}%`;
        }

        function getGitHubUsername(person) {
            const raw = person?.github ?? person?.githubUsername ?? person?.github_login ?? '';
            const s = String(raw || '').trim();
            if (s) return s;

            const name = String(person?.name || '').trim();
            const looksLikeGitHubUsername = /^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,37}[a-zA-Z0-9])?$/.test(name);
            return looksLikeGitHubUsername ? name : '';
        }

        function getGitHubAvatarUrl(username, size = 64) {
            const u = String(username || '').trim();
            if (!u) return '';
            const s = Math.max(16, Math.min(256, Number(size) || 64));
            return `https://github.com/${encodeURIComponent(u)}.png?size=${s}`;
        }

        function getInitials(name) {
            const s = String(name || '').trim();
            if (!s) return '?';
            const parts = s.split(/\s+/).filter(Boolean);
            if (parts.length === 1) return parts[0].slice(0, 2).toUpperCase();
            return `${parts[0][0] || ''}${parts[1][0] || ''}`.toUpperCase() || '?';
        }

        function createInitialsAvatarEl(personName) {
            const el = document.createElement('span');
            el.className = 'person-avatar-fallback';
            el.textContent = getInitials(personName);
            el.setAttribute('aria-hidden', 'true');
            return el;
        }

        function createPersonAvatarEl(person) {
            const personId = String(person?.id || '').trim();
            const personName = person?.name ? String(person.name) : (personId || 'Person');
            const gh = getGitHubUsername(person);
            if (!gh) return createInitialsAvatarEl(personName);

            const img = document.createElement('img');
            img.className = 'person-avatar';
            img.loading = 'lazy';
            img.decoding = 'async';
            img.referrerPolicy = 'no-referrer';
            img.alt = `${personName} (GitHub avatar)`;
            img.src = getGitHubAvatarUrl(gh, 64);
            img.addEventListener('error', () => {
                if (img.dataset.fallbackApplied === '1') return;
                img.dataset.fallbackApplied = '1';
                img.replaceWith(createInitialsAvatarEl(personName));
            });
            return img;
        }

        function renderPersonDetails({ person, container }) {
            if (!person || !container) return;
            const personId = String(person?.id || '').trim();
            if (!personId) return;

            const skills = Array.isArray(person?.skills) ? person.skills : [];
            container.innerHTML = '';

            const skillsSection = document.createElement('div');
            skillsSection.className = 'person-section';
            const skillsTitle = document.createElement('div');
            skillsTitle.className = 'person-section-title';
            skillsTitle.textContent = 'Skills';
            skillsSection.appendChild(skillsTitle);

            const skillsList = document.createElement('div');
            skillsList.className = 'person-skill-list';

            const sorted = [...skills].sort((a, b) => {
                const da = String(a?.domain || '');
                const db = String(b?.domain || '');
                const sa = String(a?.skill || '');
                const sb = String(b?.skill || '');
                return da.localeCompare(db) || sa.localeCompare(sb);
            });

            const perSkillMetrics = personIdToSkillMetrics.get(personId) || new Map();
            sorted.forEach(rec => {
                const domainName = String(rec?.domain || '').trim();
                const skillName = String(rec?.skill || '').trim();
                if (!domainName || !skillName) return;

                const skillKey = makeSkillKey(domainName, skillName);
                const meta = skillKeyToMeta.get(skillKey);
                const total = meta?.subSkillNames?.size ?? 0;
                const metric = perSkillMetrics.get(skillKey) || { usage: 0, unlockedCount: 0 };
                const unlocked = Number(metric?.unlockedCount) || 0;
                const pct01 = total > 0 ? unlocked / total : 0;
                const usage = Number(metric?.usage) || 0;

                const row = document.createElement('div');
                row.className = 'person-skill-row';

                const main = document.createElement('div');
                main.className = 'person-skill-main';
                const name = document.createElement('div');
                name.className = 'person-skill-name';
                name.textContent = skillName;
                const sub = document.createElement('div');
                sub.className = 'person-skill-sub';
                sub.textContent = `${domainName} • Usage ${Math.round(usage)}/100`;
                main.appendChild(name);
                main.appendChild(sub);

                const stat = document.createElement('div');
                stat.className = 'person-skill-stat';
                stat.textContent = total > 0 ? `${unlocked}/${total} (${formatPercent01(pct01)})` : `${unlocked} (n/a)`;

                const bar = document.createElement('div');
                bar.className = 'person-skill-bar';
                const fill = document.createElement('div');
                fill.className = 'person-skill-bar-fill';
                fill.style.width = `${Math.round(Math.max(0, Math.min(1, pct01)) * 100)}%`;
                bar.appendChild(fill);

                row.appendChild(main);
                row.appendChild(stat);
                row.appendChild(bar);
                skillsList.appendChild(row);
            });

            if (skillsList.childElementCount === 0) {
                const empty = document.createElement('div');
                empty.className = 'person-empty';
                empty.textContent = 'No skills listed for this person.';
                skillsList.appendChild(empty);
            }

            skillsSection.appendChild(skillsList);
            container.appendChild(skillsSection);

            const recoSection = document.createElement('div');
            recoSection.className = 'person-section';
            const recoTitle = document.createElement('div');
            recoTitle.className = 'person-section-title';
            recoTitle.textContent = 'AI predicted next skills';
            recoSection.appendChild(recoTitle);

            const personDomains = new Set(sorted.map(r => String(r?.domain || '').trim()).filter(Boolean));
            const recommendations = [];
            const totalPeople = Array.isArray(peopleData?.people) ? peopleData.people.length : 0;
            const perSkillAll = personIdToSkillMetrics.get(personId) || new Map();

            for (const [skillKey, meta] of skillKeyToMeta.entries()) {
                const total = meta?.subSkillNames?.size ?? 0;
                if (total <= 0) continue;
                const metric = perSkillAll.get(skillKey) || { usage: 0, unlockedCount: 0 };
                const unlocked = Number(metric?.unlockedCount) || 0;
                const completion = unlocked / total;
                if (completion >= 1) continue;

                const team = teamSkillStatsBySkillKey.get(skillKey) || { haveRatio: 0, usageAvg: 0, haveCount: 0, totalPeople };
                const domainBoost = personDomains.has(meta.domainName) ? 1 : 0.85;
                const score = (0.6 * team.haveRatio + 0.4 * (team.usageAvg / 100)) * (1 - completion) * domainBoost;

                recommendations.push({
                    skillKey,
                    domainName: meta.domainName,
                    skillName: meta.skillName,
                    completion,
                    haveRatio: team.haveRatio,
                    usageAvg: team.usageAvg,
                    haveCount: team.haveCount,
                    score
                });
            }

            recommendations.sort((a, b) => (b.score - a.score) || (a.domainName.localeCompare(b.domainName)) || (a.skillName.localeCompare(b.skillName)));
            const top = recommendations.slice(0, 5);

            const recoList = document.createElement('div');
            recoList.className = 'person-reco-list';
            if (top.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'person-empty';
                empty.textContent = 'No recommendations (all skills complete or no taxonomy data).';
                recoList.appendChild(empty);
            } else {
                top.forEach(r => {
                    const row = document.createElement('div');
                    row.className = 'person-reco-row';

                    const left = document.createElement('div');
                    left.className = 'person-reco-main';
                    const name = document.createElement('div');
                    name.className = 'person-reco-name';
                    name.textContent = r.skillName;
                    const sub = document.createElement('div');
                    sub.className = 'person-reco-sub';
                    const teamPct = formatPercent01(r.haveRatio);
                    const youPct = formatPercent01(r.completion);
                    const haveCount = Number(r.haveCount) || 0;
                    sub.textContent = `${r.domainName} • Team adoption ${teamPct} (${haveCount}/${totalPeople}) • You ${youPct}`;
                    left.appendChild(name);
                    left.appendChild(sub);

                    row.appendChild(left);

                    const bar = document.createElement('div');
                    bar.className = 'person-reco-bar';
                    const fill = document.createElement('div');
                    fill.className = 'person-reco-bar-fill';
                    fill.style.width = `${Math.round(Math.max(0, Math.min(1, Number(r.completion) || 0)) * 100)}%`;
                    bar.appendChild(fill);
                    row.appendChild(bar);

                    const usageRounded = Math.round(Number(r.usageAvg) || 0);
                    const havePctInt = Math.round(Math.max(0, Math.min(1, Number(r.haveRatio) || 0)) * 100);
                    const completionPctInt = Math.round(Math.max(0, Math.min(1, Number(r.completion) || 0)) * 100);
                    const gapPctInt = Math.max(0, 100 - completionPctInt);
                    const usageLevel = usageRounded >= 60 ? 'High' : usageRounded >= 35 ? 'Medium' : 'Low';

                    const reason = document.createElement('div');
                    reason.className = 'person-reco-reason';
                    reason.textContent = [
                        'Reasoning:',
                        `- Team usage ${usageRounded} (${usageLevel}) → likely relevant to current work`,
                        `- Completion gap ${gapPctInt}% (current ${completionPctInt}%) → worth closing the gap`,
                        `- Adoption ${havePctInt}% (${haveCount}/${totalPeople} people) → reduce single‑point knowledge risk`
                    ].join('\n');
                    row.appendChild(reason);

                    recoList.appendChild(row);
                });
            }

            recoSection.appendChild(recoList);
            container.appendChild(recoSection);
        }

        function renderTopLists() {
            const mostList = document.getElementById('topMostList');
            const leastList = document.getElementById('topLeastList');
            const mostEmpty = document.getElementById('topMostEmpty');
            const leastEmpty = document.getElementById('topLeastEmpty');

            if (!mostList || !leastList || !mostEmpty || !leastEmpty) return;

            mostList.innerHTML = '';
            leastList.innerHTML = '';

            const selectedCount = selectedPersonIds?.size || 0;
            if (!isPeopleModeEnabled()) {
                const msg = 'Multi-person mode is not enabled (people.json not loaded).';
                mostEmpty.textContent = msg;
                leastEmpty.textContent = msg;
                mostEmpty.style.display = 'block';
                leastEmpty.style.display = 'block';
                return;
            }

            if (selectedCount === 0) {
                const msg = 'Select at least one person to compute proficient skills.';
                mostEmpty.textContent = msg;
                leastEmpty.textContent = msg;
                mostEmpty.style.display = 'block';
                leastEmpty.style.display = 'block';
                return;
            }

            mostEmpty.style.display = 'none';
            leastEmpty.style.display = 'none';

            recomputeSelectionAggregates();

            const entries = [];
            for (const [skillKey, meta] of skillKeyToMeta.entries()) {
                const agg2 = selectionAggBySkillKey.get(skillKey);
                const usageSum = Number(agg2?.usageSum) || 0;
                const usageAvg = usageSum / selectedCount; // missing skill counts as 0
                entries.push({
                    skillKey,
                    domainName: meta.domainName,
                    skillName: meta.skillName,
                    usageAvg
                });
            }

            const tieBreak = (a, b) => {
                const ka = `${a.domainName}::${a.skillName}`;
                const kb = `${b.domainName}::${b.skillName}`;
                return ka.localeCompare(kb);
            };

            const most = [...entries]
                .sort((a, b) => (b.usageAvg - a.usageAvg) || tieBreak(a, b))
                .slice(0, 5);
            const least = [...entries]
                .sort((a, b) => (a.usageAvg - b.usageAvg) || tieBreak(a, b))
                .slice(0, 5);

            const renderList = (ul, items) => {
                items.forEach(it => {
                    const li = document.createElement('li');
                    li.className = 'toplist-item';

                    const left = document.createElement('div');
                    const skill = document.createElement('div');
                    skill.className = 'toplist-skill';
                    skill.textContent = it.skillName;
                    const domain = document.createElement('span');
                    domain.className = 'toplist-domain';
                    domain.textContent = it.domainName;
                    left.appendChild(skill);
                    left.appendChild(domain);

                    const stat = document.createElement('div');
                    stat.className = 'toplist-stat';
                    const avg = Math.round(it.usageAvg);
                    stat.textContent = `${avg}`;

                    li.appendChild(left);
                    li.appendChild(stat);
                    ul.appendChild(li);
                });
            };

            renderList(mostList, most);
            renderList(leastList, least);
        }

        function updatePeopleCountLabel() {
            const el = document.getElementById('peopleCount');
            if (!el) return;
            const total = Array.isArray(peopleData?.people) ? peopleData.people.length : 0;
            const selected = selectedPersonIds?.size || 0;
            el.textContent = total > 0 ? `Selected: ${selected} / ${total}` : '';
        }

        function getViewKey(data) {
            const rootName = taxonomyData?.name || 'Tech Skills';
            if (!data || !data.name) return 'overview';
            return data.name === rootName ? 'overview' : `domain::${data.name}`;
        }

        // Deterministic PRNG to reduce layout jitter between re-renders.
        // Re-initialized per computeLayout() so the initial sites are stable.
        function mulberry32(seed) {
            let t = seed >>> 0;
            return function () {
                t += 0x6D2B79F5;
                let x = t;
                x = Math.imul(x ^ (x >>> 15), x | 1);
                x ^= x + Math.imul(x ^ (x >>> 7), x | 61);
                return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
            };
        }

        // Method 1: do NOT cache. Always compute geometry from current selection weights.
        function computeLayout(data) {
            if (typeof d3.voronoiTreemap === 'undefined') return null;
            recomputeSelectionAggregates();

            const circlePolygon = createCirclePolygon(radius, 64);
            const root = d3.hierarchy(data)
                .sum(d => {
                    if (d && Array.isArray(d.children)) return 0;
                    const domainName = d?.__domain || '';
                    const skillKey = d?.__skillKey || makeSkillKey(domainName, d?.name || '');

                    if (isPeopleModeEnabled()) {
                        const metrics = getSelectionMetricsForSkillKey(skillKey);
                        if (metrics.selectedCount === 0) return 0.001;
                        return Math.max(0.001, metrics.unlockedSum);
                    }

                    return Math.max(0.001, getSubSkillCounts(d).unlocked);
                })
                // Keep node ordering stable to reduce movement between selections.
                // Sorting by value causes reordering when weights change, increasing jitter.
                .sort((a, b) => {
                    const ka = String(a?.data?.__skillKey || a?.data?.name || '');
                    const kb = String(b?.data?.__skillKey || b?.data?.name || '');
                    return ka.localeCompare(kb);
                });

            const voronoiTreemap = d3.voronoiTreemap()
                .clip(circlePolygon)
                .convergenceRatio(0.001)
                .maxIterationCount(100)
                .minWeightRatio(0.001)
                .prng(mulberry32(1337));

            voronoiTreemap(root);
            return {
                root,
                leaves: root.leaves(),
                domains: root.children || []
            };
        }

        function applySelectionStyles(svg) {
            const cells = svg.selectAll('.skill-cell');
            if (cells.empty()) return;

            if (!isPeopleModeEnabled()) {
                cells
                    .attr('fill', d => {
                        const domainName = d?.data?.__domain || (d?.parent ? d.parent.data.name : 'Unknown');
                        const colorScheme = domainColorSchemes[domainName] || d3.interpolateRainbow;
                        return colorScheme(usageTGlobal(getUsageValue(d?.data)));
                    })
                    .attr('opacity', 0.9);
                return;
            }

            // recomputeSelectionAggregates was called by computeLayout already, but keep it safe
            recomputeSelectionAggregates();

            cells
                .attr('fill', d => {
                    const domainName = d?.data?.__domain || (d?.parent ? d.parent.data.name : 'Unknown');
                    const skillKey = d?.data?.__skillKey || makeSkillKey(domainName, d?.data?.name || '');
                    const metrics = getSelectionMetricsForSkillKey(skillKey);
                    const colorScheme = domainColorSchemes[domainName] || d3.interpolateRainbow;
                    return colorScheme(usageTGlobal(metrics.usageAvg));
                })
                .attr('opacity', d => {
                    const domainName = d?.data?.__domain || (d?.parent ? d.parent.data.name : 'Unknown');
                    const skillKey = d?.data?.__skillKey || makeSkillKey(domainName, d?.data?.name || '');
                    const metrics = getSelectionMetricsForSkillKey(skillKey);
                    if (metrics.selectedCount === 0) return 0.15;
                    return 0.25 + 0.75 * metrics.unlockedPeopleRatio;
                });
        }

        function renderChart(data) {
            d3.select('#chart').selectAll('*').remove();

            const svg = d3.select('#chart')
                .attr('width', width)
                .attr('height', height);

            const centerX = width / 2;
            const centerY = height / 2;

            const viewKey = getViewKey(data);
            const isWorldView = viewKey === 'overview';
            const layout = computeLayout(data);
            const root = layout?.root || null;

            // Draw outer circle border (removed per request)
            svg.append('circle')
                .attr('cx', centerX)
                .attr('cy', centerY)
                .attr('r', radius)
                .attr('fill', 'none')
                .attr('stroke', 'none')
                .attr('stroke-width', 0);

            // Create circular clip path
            const defs = svg.append('defs');
            defs.append('clipPath')
                .attr('id', 'circle-clip')
                .append('circle')
                .attr('cx', 0)
                .attr('cy', 0)
                .attr('r', radius);

            const g = svg.append('g')
                .attr('transform', `translate(${centerX},${centerY})`)
                .attr('clip-path', 'url(#circle-clip)');

            if (!layout) {
                g.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#666')
                    .attr('font-size', '14px')
                    .text('⚠️ d3-voronoi-treemap layout is unavailable');
                return;
            }

            const leaves = layout.leaves;
            const domains = layout.domains;

            g.selectAll('.skill-cell')
                .data(leaves)
                .join('path')
                .attr('class', 'skill-cell')
                .attr('d', d => d.polygon ? "M" + d.polygon.join("L") + "Z" : null)
                .attr('fill', '#ddd')
                .attr('stroke', '#fff')
                .attr('stroke-width', 1.5)
                .attr('opacity', 0.9)
                .style('cursor', isWorldView ? 'pointer' : 'default')
                .on('click', function (event, d) {
                    event.stopPropagation();
                    if (isWorldView && d.parent && d.parent.data.name !== (taxonomyData?.name || 'Tech Skills')) {
                        drillDown(d.parent.data);
                    }
                })
                .on('mouseover', function (event, d) {
                    d3.select(this).attr('opacity', 1).attr('stroke-width', 3);
                    const tooltip = document.getElementById('tooltip');
                    tooltip.style.display = 'block';

                    const domainName = d.parent ? d.parent.data.name : (d?.data?.__domain || '');
                    const skillKey = d?.data?.__skillKey || makeSkillKey(domainName, d?.data?.name || '');
                    const totalValue = root?.value || 1;
                    const percentage = ((d.value || 0) / totalValue * 100).toFixed(1);

                    if (isPeopleModeEnabled()) {
                        const metrics = getSelectionMetricsForSkillKey(skillKey);
                        const usageAvg = Math.round(metrics.usageAvg);
                        tooltip.innerHTML = `
                            <strong>${d.data.name} (${domainName})</strong>
                            <div>Selected unlocked (sum): ${metrics.unlockedSum}</div>
                            <div>Avg usage (selected): ${usageAvg}</div>
                            <div>% of selected total (unlocked sum): ${percentage}%</div>
                            ${metrics.selectedCount === 0 ? '<div style="margin-top: 4px; font-style: italic;">No people selected</div>' : ''}
                        `;
                    } else {
                        const { unlocked, total } = getSubSkillCounts(d.data);
                        const usage = getUsageValue(d.data);
                        tooltip.innerHTML = `
                            <strong>${d.data.name} (${domainName})</strong>
                            <div>Unlocked sub-skills: ${unlocked}/${total}</div>
                            <div>Usage frequency: ${usage}</div>
                            <div>% of Total (unlocked): ${percentage}%</div>
                        `;
                    }

                    positionTooltip(event, tooltip);
                })
                .on('mousemove', function (event) {
                    const tooltip = document.getElementById('tooltip');
                    if (tooltip?.style?.display === 'block') positionTooltip(event, tooltip);
                })
                .on('mouseout', function () {
                    const tooltip = document.getElementById('tooltip');
                    tooltip.style.display = 'none';
                    applySelectionStyles(svg);
                });

            // Domain borders in overview (removed per request)
            if (isWorldView) {
                g.selectAll('.domain-border')
                    .data(domains)
                    .join('path')
                    .attr('class', 'domain-border')
                    .attr('d', d => d.polygon ? "M" + d.polygon.join("L") + "Z" : null)
                    .attr('fill', 'none')
                    .attr('stroke', 'none')
                    .attr('stroke-width', 0)
                    .style('pointer-events', 'none');
            }

            // Labels
            g.selectAll('.skill-label')
                .data(leaves)
                .join('text')
                .attr('class', 'skill-label')
                .attr('x', d => d.polygon ? d3.polygonCentroid(d.polygon)[0] : 0)
                .attr('y', d => d.polygon ? d3.polygonCentroid(d.polygon)[1] : 0)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('fill', '#fff')
                .attr('font-size', d => {
                    if (!d.polygon) return '10px';
                    const area = Math.abs(d3.polygonArea(d.polygon));
                    return Math.max(8, Math.min(18, Math.sqrt(area) / 10)) + 'px';
                })
                .attr('font-weight', 'bold')
                .style('pointer-events', 'none')
                .text(d => {
                    if (!d.polygon) return '';
                    const area = Math.abs(d3.polygonArea(d.polygon));
                    const name = d.data.name;
                    if (area > 8000) return name;
                    if (area > 4000) return name.length > 10 ? name.substring(0, 10) : name;
                    if (area > 2000) return name.length > 6 ? name.substring(0, 6) : name;
                    return '';
                });

            // Domain labels (outside the circle) in overview
            // Kept consistent with index.html
            if (isWorldView) {
                const domainNodes = Array.isArray(root?.children) ? root.children : [];
                domainNodes.forEach(domain => {
                    if (!domain?.polygon || domain.polygon.length < 3) return;

                    const domainName = String(domain?.data?.name || '');
                    const colorScheme = domainColorSchemes[domainName] || d3.interpolateRainbow;
                    const badgeFill = colorScheme(0.75);

                    const centroid = d3.polygonCentroid(domain.polygon);
                    const angle = Math.atan2(centroid[1], centroid[0]);
                    const labelRadius = radius + 50;
                    const labelX = centerX + Math.cos(angle) * labelRadius;
                    const labelY = centerY + Math.sin(angle) * labelRadius;

                    const textElement = svg.append('text')
                        .attr('class', 'domain-label')
                        .attr('x', labelX)
                        .attr('y', labelY)
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'middle')
                        .attr('fill', '#fff')
                        .attr('font-size', '15px')
                        .attr('font-weight', 'bold')
                        .style('pointer-events', 'none')
                        .text(domainName);

                    const bbox = textElement.node().getBBox();
                    svg.insert('rect', () => textElement.node())
                        .attr('class', 'domain-badge')
                        .attr('x', bbox.x - 10)
                        .attr('y', bbox.y - 6)
                        .attr('width', bbox.width + 20)
                        .attr('height', bbox.height + 12)
                        .attr('fill', badgeFill)
                        .attr('opacity', 0.96)
                        .attr('rx', 10)
                        .attr('ry', 10)
                        .attr('stroke', 'none')
                        .attr('stroke-width', 0)
                        .style('filter', 'drop-shadow(0px 6px 10px rgba(0, 0, 0, 0.18))')
                        .style('pointer-events', 'none');
                });
            }

            svg.on('click', () => {
                if (history.length > 0) goBack();
            });

            applySelectionStyles(svg);
            renderTopLists();
            updateControls();
        }

        function drillDown(data) {
            history.push(currentData);
            currentData = data;
            renderChart(currentData);
        }

        function goBack() {
            if (history.length > 0) {
                currentData = history.pop();
                renderChart(currentData);
            }
        }

        function reset() {
            currentData = taxonomyData;
            history = [];
            renderChart(currentData);
        }

        function updateControls() {
            const controls = document.getElementById('controls');
            const breadcrumb = document.getElementById('breadcrumb');
            const mainTitle = document.getElementById('mainTitle');
            const subtitle = document.getElementById('subtitle');

            if (currentData !== taxonomyData || history.length > 0) {
                controls.style.display = 'flex';
                breadcrumb.textContent = currentData !== taxonomyData ? `Current: ${currentData.name}` : '';
                mainTitle.textContent = `Programming Skills Map`;
                subtitle.textContent = 'Method 1: dynamic geometry (areas recomputed per selection)';
            } else {
                controls.style.display = 'none';
                mainTitle.textContent = 'Programming Skills Map';
                subtitle.textContent = 'Method 1: dynamic geometry (areas recomputed per selection)';
            }
        }

        function scheduleRender() {
            if (renderDebounceTimer) window.clearTimeout(renderDebounceTimer);
            renderDebounceTimer = window.setTimeout(() => {
                renderDebounceTimer = null;
                renderChart(currentData);
            }, 80);
        }

        function initPeopleUI(people) {
            const panel = document.getElementById('peoplePanel');
            const list = document.getElementById('peopleList');
            const selectAllBtn = document.getElementById('selectAllPeopleBtn');
            const clearBtn = document.getElementById('clearPeopleBtn');
            const searchInput = document.getElementById('peopleSearch');
            const detailsBackdrop = document.getElementById('peopleDetailsBackdrop');
            const detailsTitle = document.getElementById('peopleDetailsTitle');
            const detailsBody = document.getElementById('peopleDetailsBody');
            const detailsCloseBtn = document.getElementById('peopleDetailsCloseBtn');

            if (!panel || !list || !selectAllBtn || !clearBtn || !detailsBackdrop || !detailsTitle || !detailsBody || !detailsCloseBtn) return;

            const persons = Array.isArray(people) ? people : [];
            if (persons.length === 0) {
                panel.style.display = 'none';
                return;
            }

            panel.style.display = 'block';
            list.innerHTML = '';
            if (searchInput) searchInput.value = '';

            // Default: all selected
            selectedPersonIds = new Set(persons.map(p => String(p?.id || '').trim()).filter(Boolean));
            updatePeopleCountLabel();

            const closeDetails = () => {
                if (detailsBackdrop.dataset.open !== '1') return;
                detailsBackdrop.dataset.open = '0';
                detailsBackdrop.setAttribute('aria-hidden', 'true');
                document.body.classList.remove('people-details-open');
            };

            const openDetails = (person) => {
                if (!person) return;
                const personId = String(person?.id || '').trim();
                const personName = person?.name ? String(person.name) : personId;
                detailsTitle.textContent = personName || 'Details';
                detailsBody.innerHTML = '';
                renderPersonDetails({ person, container: detailsBody });
                detailsBackdrop.dataset.open = '1';
                detailsBackdrop.setAttribute('aria-hidden', 'false');
                document.body.classList.add('people-details-open');
            };

            if (detailsBackdrop.dataset.bound !== '1') {
                detailsBackdrop.dataset.bound = '1';
                detailsCloseBtn.addEventListener('click', closeDetails);
                detailsBackdrop.addEventListener('click', (e) => {
                    if (e.target === detailsBackdrop) closeDetails();
                });
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') closeDetails();
                });
            }

            const fragment = document.createDocumentFragment();

            persons.forEach(person => {
                const personId = String(person?.id || '').trim();
                if (!personId) return;
                const personName = person?.name ? String(person.name) : personId;

                const item = document.createElement('div');
                item.className = 'person-item';
                item.dataset.personId = personId;
                item.dataset.searchText = `${personName} ${personId}`.toLowerCase();

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'person-checkbox';
                checkbox.checked = true;
                checkbox.id = `person-check-${personId}`;
                checkbox.setAttribute('aria-label', `Select ${personName}`);
                checkbox.addEventListener('change', () => {
                    if (checkbox.checked) selectedPersonIds.add(personId);
                    else selectedPersonIds.delete(personId);
                    updatePeopleCountLabel();
                    scheduleRender();
                });

                const label = document.createElement('label');
                label.className = 'person-name';
                label.htmlFor = checkbox.id;
                label.textContent = personName;

                const avatar = createPersonAvatarEl(person);

                const detailsBtn = document.createElement('button');
                detailsBtn.type = 'button';
                detailsBtn.className = 'person-details-btn';
                detailsBtn.textContent = 'Details';
                detailsBtn.setAttribute('aria-label', `View details for ${personName}`);
                detailsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    openDetails(person);
                });

                // Click on row toggles the checkbox (avoid double-toggle when clicking the checkbox/label/button)
                item.addEventListener('click', (e) => {
                    const t = e.target;
                    if (t === checkbox) return;
                    if (t && t.tagName === 'LABEL') return;
                    if (t && t.tagName === 'BUTTON') return;
                    checkbox.checked = !checkbox.checked;
                    checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                });

                item.appendChild(checkbox);
                item.appendChild(avatar);
                item.appendChild(label);
                item.appendChild(detailsBtn);
                fragment.appendChild(item);
            });

            list.appendChild(fragment);

            if (searchInput) {
                searchInput.oninput = () => {
                    const q = String(searchInput.value || '').trim().toLowerCase();
                    list.querySelectorAll('.person-item').forEach(item => {
                        const txt = String(item?.dataset?.searchText || '');
                        item.style.display = q === '' || txt.includes(q) ? '' : 'none';
                    });
                };
            }

            selectAllBtn.onclick = () => {
                selectedPersonIds = new Set(persons.map(p => String(p?.id || '').trim()).filter(Boolean));
                list.querySelectorAll('.person-item .person-checkbox').forEach(cb => cb.checked = true);
                updatePeopleCountLabel();
                scheduleRender();
            };

            clearBtn.onclick = () => {
                selectedPersonIds = new Set();
                list.querySelectorAll('.person-item .person-checkbox').forEach(cb => cb.checked = false);
                updatePeopleCountLabel();
                scheduleRender();
            };
        }

        function extractBaseTaxonomyFromIndexHtml(indexHtmlText) {
            const marker = 'const baseTaxonomy =';
            const idx = indexHtmlText.indexOf(marker);
            if (idx === -1) throw new Error('Could not find baseTaxonomy in index.html');
            const after = indexHtmlText.slice(idx + marker.length);
            const braceStart = after.indexOf('{');
            if (braceStart === -1) throw new Error('Could not find { for baseTaxonomy');

            const startPos = idx + marker.length + braceStart;
            let depth = 0;
            let inStr = false;
            let strQuote = '';
            for (let i = startPos; i < indexHtmlText.length; i++) {
                const ch = indexHtmlText[i];
                const prev = indexHtmlText[i - 1];
                if (inStr) {
                    if (ch === strQuote && prev !== '\\\\') {
                        inStr = false;
                        strQuote = '';
                    }
                    continue;
                }
                if (ch === "'" || ch === '"' || ch === '`') {
                    inStr = true;
                    strQuote = ch;
                    continue;
                }
                if (ch === '{') depth += 1;
                if (ch === '}') depth -= 1;
                if (depth === 0) {
                    const objText = indexHtmlText.slice(startPos, i + 1);
                    // Evaluate trusted local content (same repo file)
                    // eslint-disable-next-line no-new-func
                    return (new Function(`return (${objText});`))();
                }
            }
            throw new Error('Unterminated baseTaxonomy object');
        }

        async function initApp() {
            // Load taxonomy from method2 page to keep them in sync without duplicating the big object.
            try {
                const indexText = await fetch('./index.html', { cache: 'no-store' }).then(r => r.text());
                baseTaxonomy = extractBaseTaxonomyFromIndexHtml(indexText);
            } catch (e) {
                console.warn('Failed to load baseTaxonomy from index.html, using empty taxonomy:', e);
                baseTaxonomy = { name: 'Tech Skills', children: [] };
            }

            taxonomyData = cloneObject(baseTaxonomy);
            currentData = taxonomyData;
            history = [];

            try {
                const resp = await fetch('./people.json', { cache: 'no-store' });
                if (!resp.ok) throw new Error(`Failed to load people.json (${resp.status})`);
                peopleData = await resp.json();
                const persons = Array.isArray(peopleData?.people) ? peopleData.people : [];

                applyPeopleUnionToTaxonomy(taxonomyData, persons);
                annotateAndIndexTaxonomy(taxonomyData);
                buildPeopleMetrics(persons);
                computeTeamSkillStats(persons);
                initPeopleUI(persons);
            } catch (err) {
                console.warn('People mode disabled:', err);
                peopleData = null;
                selectedPersonIds = new Set();
                const panel = document.getElementById('peoplePanel');
                if (panel) panel.style.display = 'none';
                annotateAndIndexTaxonomy(taxonomyData);
            }

            renderChart(currentData);
        }

        initApp();
    </script>
</body>

</html>
