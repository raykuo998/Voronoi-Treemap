<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programming Skills Map - Method 1 (Dynamic Geometry)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            color: rgba(255, 255, 255, 0.9);
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.1rem;
        }

        .method-badge {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            display: inline-block;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            display: none;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .people-panel {
            background: white;
            padding: 16px 18px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            margin-bottom: 16px;
            display: none;
        }

        .people-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .people-search {
            flex: 1 1 240px;
            max-width: 420px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .people-search input[type="text"] {
            width: 100%;
            padding: 9px 10px;
            border-radius: 10px;
            border: 1px solid rgba(0, 0, 0, 0.12);
            outline: none;
            font-size: 13px;
            font-weight: 600;
            color: #333;
            background: rgba(0, 0, 0, 0.02);
        }

        .people-search input[type="text"]:focus {
            border-color: rgba(102, 126, 234, 0.7);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.15);
            background: white;
        }

        .people-panel-title {
            font-weight: 800;
            color: #333;
            font-size: 14px;
            letter-spacing: 0.02em;
        }

        .people-panel-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .people-panel-actions button {
            padding: 8px 12px;
            font-size: 13px;
        }

        .people-count {
            color: #666;
            font-size: 13px;
            font-weight: 600;
        }

        .people-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 10px 16px;
            max-height: 220px;
            overflow: auto;
            padding-right: 6px;
        }

        .people-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            border-radius: 10px;
            border: 1px solid rgba(0, 0, 0, 0.06);
            background: rgba(102, 126, 234, 0.04);
        }

        .people-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .people-item label {
            cursor: pointer;
            color: #333;
            font-size: 13px;
            font-weight: 600;
            user-select: none;
        }

        button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.6);
        }

        button:active {
            transform: translateY(0);
        }

        .back-btn {
            background: #6c757d;
        }

        .back-btn:hover {
            background: #5a6268;
        }

        .breadcrumb {
            color: #333;
            font-size: 14px;
            font-weight: 500;
        }

        .chart-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            padding: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .tooltip {
            position: fixed;
            display: none;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            pointer-events: none;
            z-index: 1000;
            max-width: 280px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            line-height: 1.6;
            backdrop-filter: blur(10px);
        }

        .tooltip strong {
            display: block;
            margin-bottom: 6px;
            font-size: 15px;
            color: #fff;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            button {
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1 id="mainTitle">Programming Skills Map</h1>
        <p class="subtitle" id="subtitle">Method 1: dynamic geometry (areas recomputed per selection)</p>
        <div style="text-align: center;">
            <span class="method-badge">Method 1 (Dynamic): area = sum of selected unlocked sub-skills</span>
        </div>

        <div class="people-panel" id="peoplePanel">
            <div class="people-panel-header">
                <div class="people-panel-title">People filter</div>
                <div class="people-search">
                    <input type="text" id="peopleSearch" placeholder="Search people..." />
                </div>
                <div class="people-panel-actions">
                    <span class="people-count" id="peopleCount"></span>
                    <button type="button" id="selectAllPeopleBtn">Select all</button>
                    <button type="button" class="back-btn" id="clearPeopleBtn">Clear</button>
                </div>
            </div>
            <div class="people-list" id="peopleList"></div>
        </div>

        <div class="controls" id="controls">
            <button class="back-btn" id="backBtn" onclick="goBack()">← Back</button>
            <button id="resetBtn" onclick="reset()">⌂ Reset to Overview</button>
            <span class="breadcrumb" id="breadcrumb"></span>
        </div>

        <div class="chart-container">
            <svg id="chart"></svg>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-weighted-voronoi@1"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-voronoi-map@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-voronoi-treemap@1"></script>
    <script>
        if (typeof d3 === 'undefined') {
            document.body.innerHTML = '<div style="text-align:center;padding:50px;"><h2>⚠️ D3.js Failed to Load</h2><p>Please check your internet connection</p></div>';
            throw new Error('D3.js failed to load');
        }
    </script>

    <script>
        const cloneObject = typeof structuredClone === 'function'
            ? structuredClone
            : (obj) => JSON.parse(JSON.stringify(obj));

        // Global variables
        let baseTaxonomy = null; // loaded from index.html
        let taxonomyData = null;
        let currentData = null;
        let history = [];
        const width = 1000;
        const height = 1000;
        const radius = Math.min(width, height) / 2 - 80;

        // Multi-person state (method 1: dynamic geometry, recompute Voronoi per selection)
        let peopleData = null;
        let selectedPersonIds = new Set();
        let skillKeyToMeta = new Map(); // skillKey -> { domainName, skillName, subSkillNames:Set<string> }
        let personIdToSkillMetrics = new Map(); // personId -> Map(skillKey -> { usage:number, unlockedCount:number })
        let usageTGlobal = () => 0.6; // (usage:number) -> t in [0,1]
        let selectionAggBySkillKey = new Map(); // skillKey -> { usageSum, unlockedSum, unlockedPeopleCount }
        let selectionAggSelectedCount = 0;
        let renderDebounceTimer = null;

        // Domain color schemes
        const domainColorSchemes = {
            'Frontend': d3.interpolateBlues,
            'Backend': d3.interpolateGreens,
            'DevOps': d3.interpolateOranges,
            'Mobile': d3.interpolatePurples
        };

        function makeSkillKey(domainName, skillName) {
            return `${domainName}::${skillName}`;
        }

        function isPeopleModeEnabled() {
            return Array.isArray(peopleData?.people) && peopleData.people.length > 0;
        }

        function positionTooltip(event, tooltip) {
            if (!tooltip) return;
            const offset = 12;
            const pad = 8;

            const clientX = Number(event?.clientX);
            const clientY = Number(event?.clientY);
            const x0 = Number.isFinite(clientX) ? clientX : 0;
            const y0 = Number.isFinite(clientY) ? clientY : 0;

            const rect = tooltip.getBoundingClientRect();

            let x = x0 + offset;
            let y = y0 + offset;

            if (x + rect.width + pad > window.innerWidth) x = x0 - rect.width - offset;
            if (y + rect.height + pad > window.innerHeight) y = y0 - rect.height - offset;

            x = Math.max(pad, Math.min(window.innerWidth - rect.width - pad, x));
            y = Math.max(pad, Math.min(window.innerHeight - rect.height - pad, y));

            tooltip.style.left = Math.round(x) + 'px';
            tooltip.style.top = Math.round(y) + 'px';
        }

        function createCirclePolygon(r, points = 64) {
            const circlePolygon = [];
            for (let i = 0; i < points; i++) {
                const angle = (i / points) * 2 * Math.PI;
                circlePolygon.push([Math.cos(angle) * r, Math.sin(angle) * r]);
            }
            return circlePolygon;
        }

        function getSubSkillCounts(skill) {
            const subSkills = Array.isArray(skill?.subSkills) ? skill.subSkills : [];
            const total = subSkills.length;
            const unlocked = subSkills.reduce((acc, s) => acc + (s && s.unlocked ? 1 : 0), 0);
            return { unlocked, total };
        }

        function getUsageValue(skill) {
            const usage = Number(skill?.usage);
            return Number.isFinite(usage) ? usage : 0;
        }

        function createGlobalUsageIntensityScaleFromValues(values) {
            const numeric = (Array.isArray(values) ? values : [])
                .map(v => Number(v))
                .filter(v => Number.isFinite(v));
            const extent = d3.extent(numeric);
            const hasRange =
                Number.isFinite(extent[0]) &&
                Number.isFinite(extent[1]) &&
                extent[0] !== extent[1];
            return hasRange
                ? d3.scaleLinear().domain(extent).range([0.15, 0.95]).clamp(true)
                : () => 0.6;
        }

        function ensureDomainNode(taxonomy, domainName) {
            if (!taxonomy) return null;
            if (!Array.isArray(taxonomy.children)) taxonomy.children = [];
            const existing = taxonomy.children.find(d => d && d.name === domainName) || null;
            if (existing) return existing;
            const domainNode = { name: domainName, children: [] };
            taxonomy.children.push(domainNode);
            return domainNode;
        }

        function ensureSkillNode(domainNode, skillName) {
            if (!domainNode) return null;
            if (!Array.isArray(domainNode.children)) domainNode.children = [];
            const existing = domainNode.children.find(s => s && s.name === skillName) || null;
            if (existing) return existing;
            const skillNode = { name: skillName, usage: 0, subSkills: [] };
            domainNode.children.push(skillNode);
            return skillNode;
        }

        function ensureSubSkillNames(skillNode, names) {
            if (!skillNode) return;
            if (!Array.isArray(skillNode.subSkills)) skillNode.subSkills = [];
            const existing = new Set(skillNode.subSkills.map(s => s && s.name).filter(Boolean));
            (Array.isArray(names) ? names : []).forEach(name => {
                if (!name || existing.has(name)) return;
                skillNode.subSkills.push({ name, unlocked: false });
                existing.add(name);
            });
        }

        function applyPeopleUnionToTaxonomy(taxonomy, people) {
            const persons = Array.isArray(people) ? people : [];
            persons.forEach(person => {
                const skills = Array.isArray(person?.skills) ? person.skills : [];
                skills.forEach(rec => {
                    const domainName = String(rec?.domain || '').trim();
                    const skillName = String(rec?.skill || '').trim();
                    if (!domainName || !skillName) return;
                    const domainNode = ensureDomainNode(taxonomy, domainName);
                    const skillNode = ensureSkillNode(domainNode, skillName);
                    ensureSubSkillNames(skillNode, rec?.unlockedSubSkills);
                });
            });
        }

        function annotateAndIndexTaxonomy(taxonomy) {
            skillKeyToMeta = new Map();
            const domains = Array.isArray(taxonomy?.children) ? taxonomy.children : [];
            domains.forEach(domain => {
                const domainName = domain?.name;
                const skills = Array.isArray(domain?.children) ? domain.children : [];
                skills.forEach(skill => {
                    if (!skill || !domainName || !skill.name) return;
                    skill.__domain = domainName;
                    skill.__skillKey = makeSkillKey(domainName, skill.name);
                    const subSkillNames = new Set(
                        (Array.isArray(skill.subSkills) ? skill.subSkills : [])
                            .map(s => s && s.name)
                            .filter(Boolean)
                    );
                    skillKeyToMeta.set(skill.__skillKey, { domainName, skillName: skill.name, subSkillNames });
                });
            });
        }

        function buildPeopleMetrics(people) {
            personIdToSkillMetrics = new Map();
            const persons = Array.isArray(people) ? people : [];
            const usageValues = [];

            persons.forEach(person => {
                const id = String(person?.id || '').trim();
                if (!id) return;
                personIdToSkillMetrics.set(id, new Map());
                const skills = Array.isArray(person?.skills) ? person.skills : [];
                skills.forEach(rec => {
                    const domainName = String(rec?.domain || '').trim();
                    const skillName = String(rec?.skill || '').trim();
                    if (!domainName || !skillName) return;
                    const skillKey = makeSkillKey(domainName, skillName);
                    const usage = Number(rec?.usage);
                    const usageValue = Number.isFinite(usage) ? usage : 0;
                    const unlockedNames = Array.isArray(rec?.unlockedSubSkills) ? rec.unlockedSubSkills : [];

                    const meta = skillKeyToMeta.get(skillKey);
                    let unlockedCount = 0;
                    if (meta && meta.subSkillNames && meta.subSkillNames.size > 0) {
                        const seen = new Set();
                        unlockedNames.forEach(n => {
                            const name = String(n || '').trim();
                            if (!name || seen.has(name)) return;
                            if (meta.subSkillNames.has(name)) {
                                unlockedCount += 1;
                                seen.add(name);
                            }
                        });
                    } else {
                        unlockedCount = unlockedNames.length;
                    }

                    personIdToSkillMetrics.get(id).set(skillKey, { usage: usageValue, unlockedCount });
                    usageValues.push(usageValue);
                });
            });

            usageTGlobal = createGlobalUsageIntensityScaleFromValues([0, ...usageValues]);
        }

        function recomputeSelectionAggregates() {
            selectionAggSelectedCount = selectedPersonIds?.size || 0;
            selectionAggBySkillKey = new Map();
            if (!isPeopleModeEnabled()) return;

            for (const personId of selectedPersonIds) {
                const perSkill = personIdToSkillMetrics.get(personId);
                if (!perSkill) continue;
                for (const [skillKey, metric] of perSkill.entries()) {
                    const usage = Number(metric?.usage) || 0;
                    const unlocked = Number(metric?.unlockedCount) || 0;
                    if (usage === 0 && unlocked === 0) continue;

                    let agg = selectionAggBySkillKey.get(skillKey);
                    if (!agg) {
                        agg = { usageSum: 0, unlockedSum: 0, unlockedPeopleCount: 0 };
                        selectionAggBySkillKey.set(skillKey, agg);
                    }

                    agg.usageSum += usage;
                    agg.unlockedSum += unlocked;
                    if (unlocked > 0) agg.unlockedPeopleCount += 1;
                }
            }
        }

        function getSelectionMetricsForSkillKey(skillKey) {
            const selectedCount = selectionAggSelectedCount;
            const agg = selectionAggBySkillKey.get(skillKey) || { usageSum: 0, unlockedSum: 0, unlockedPeopleCount: 0 };

            if (selectedCount === 0) {
                return {
                    selectedCount: 0,
                    unlockedPeopleCount: 0,
                    unlockedPeopleRatio: 0,
                    usageAvg: 0,
                    unlockedSum: 0
                };
            }

            return {
                selectedCount,
                unlockedPeopleCount: agg.unlockedPeopleCount,
                unlockedPeopleRatio: agg.unlockedPeopleCount / selectedCount,
                usageAvg: agg.usageSum / selectedCount,
                unlockedSum: agg.unlockedSum
            };
        }

        function updatePeopleCountLabel() {
            const el = document.getElementById('peopleCount');
            if (!el) return;
            const total = Array.isArray(peopleData?.people) ? peopleData.people.length : 0;
            const selected = selectedPersonIds?.size || 0;
            el.textContent = total > 0 ? `Selected: ${selected} / ${total}` : '';
        }

        function getViewKey(data) {
            const rootName = taxonomyData?.name || 'Tech Skills';
            if (!data || !data.name) return 'overview';
            return data.name === rootName ? 'overview' : `domain::${data.name}`;
        }

        // Deterministic PRNG to reduce layout jitter between re-renders.
        // Re-initialized per computeLayout() so the initial sites are stable.
        function mulberry32(seed) {
            let t = seed >>> 0;
            return function () {
                t += 0x6D2B79F5;
                let x = t;
                x = Math.imul(x ^ (x >>> 15), x | 1);
                x ^= x + Math.imul(x ^ (x >>> 7), x | 61);
                return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
            };
        }

        // Method 1: do NOT cache. Always compute geometry from current selection weights.
        function computeLayout(data) {
            if (typeof d3.voronoiTreemap === 'undefined') return null;
            recomputeSelectionAggregates();

            const circlePolygon = createCirclePolygon(radius, 64);
            const root = d3.hierarchy(data)
                .sum(d => {
                    if (d && Array.isArray(d.children)) return 0;
                    const domainName = d?.__domain || '';
                    const skillKey = d?.__skillKey || makeSkillKey(domainName, d?.name || '');

                    if (isPeopleModeEnabled()) {
                        const metrics = getSelectionMetricsForSkillKey(skillKey);
                        if (metrics.selectedCount === 0) return 0.001;
                        return Math.max(0.001, metrics.unlockedSum);
                    }

                    return Math.max(0.001, getSubSkillCounts(d).unlocked);
                })
                // Keep node ordering stable to reduce movement between selections.
                // Sorting by value causes reordering when weights change, increasing jitter.
                .sort((a, b) => {
                    const ka = String(a?.data?.__skillKey || a?.data?.name || '');
                    const kb = String(b?.data?.__skillKey || b?.data?.name || '');
                    return ka.localeCompare(kb);
                });

            const voronoiTreemap = d3.voronoiTreemap()
                .clip(circlePolygon)
                .convergenceRatio(0.001)
                .maxIterationCount(100)
                .minWeightRatio(0.001)
                .prng(mulberry32(1337));

            voronoiTreemap(root);
            return {
                root,
                leaves: root.leaves(),
                domains: root.children || []
            };
        }

        function applySelectionStyles(svg) {
            const cells = svg.selectAll('.skill-cell');
            if (cells.empty()) return;

            if (!isPeopleModeEnabled()) {
                cells
                    .attr('fill', d => {
                        const domainName = d?.data?.__domain || (d?.parent ? d.parent.data.name : 'Unknown');
                        const colorScheme = domainColorSchemes[domainName] || d3.interpolateRainbow;
                        return colorScheme(usageTGlobal(getUsageValue(d?.data)));
                    })
                    .attr('opacity', 0.9);
                return;
            }

            // recomputeSelectionAggregates was called by computeLayout already, but keep it safe
            recomputeSelectionAggregates();

            cells
                .attr('fill', d => {
                    const domainName = d?.data?.__domain || (d?.parent ? d.parent.data.name : 'Unknown');
                    const skillKey = d?.data?.__skillKey || makeSkillKey(domainName, d?.data?.name || '');
                    const metrics = getSelectionMetricsForSkillKey(skillKey);
                    const colorScheme = domainColorSchemes[domainName] || d3.interpolateRainbow;
                    return colorScheme(usageTGlobal(metrics.usageAvg));
                })
                .attr('opacity', d => {
                    const domainName = d?.data?.__domain || (d?.parent ? d.parent.data.name : 'Unknown');
                    const skillKey = d?.data?.__skillKey || makeSkillKey(domainName, d?.data?.name || '');
                    const metrics = getSelectionMetricsForSkillKey(skillKey);
                    if (metrics.selectedCount === 0) return 0.15;
                    return 0.25 + 0.75 * metrics.unlockedPeopleRatio;
                });
        }

        function renderChart(data) {
            d3.select('#chart').selectAll('*').remove();

            const svg = d3.select('#chart')
                .attr('width', width)
                .attr('height', height);

            const centerX = width / 2;
            const centerY = height / 2;

            const viewKey = getViewKey(data);
            const isWorldView = viewKey === 'overview';
            const layout = computeLayout(data);
            const root = layout?.root || null;

            // Draw outer circle border (removed per request)
            svg.append('circle')
                .attr('cx', centerX)
                .attr('cy', centerY)
                .attr('r', radius)
                .attr('fill', 'none')
                .attr('stroke', 'none')
                .attr('stroke-width', 0);

            // Create circular clip path
            const defs = svg.append('defs');
            defs.append('clipPath')
                .attr('id', 'circle-clip')
                .append('circle')
                .attr('cx', 0)
                .attr('cy', 0)
                .attr('r', radius);

            const g = svg.append('g')
                .attr('transform', `translate(${centerX},${centerY})`)
                .attr('clip-path', 'url(#circle-clip)');

            if (!layout) {
                g.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#666')
                    .attr('font-size', '14px')
                    .text('⚠️ d3-voronoi-treemap layout is unavailable');
                return;
            }

            const leaves = layout.leaves;
            const domains = layout.domains;

            g.selectAll('.skill-cell')
                .data(leaves)
                .join('path')
                .attr('class', 'skill-cell')
                .attr('d', d => d.polygon ? "M" + d.polygon.join("L") + "Z" : null)
                .attr('fill', '#ddd')
                .attr('stroke', '#fff')
                .attr('stroke-width', 1.5)
                .attr('opacity', 0.9)
                .style('cursor', isWorldView ? 'pointer' : 'default')
                .on('click', function (event, d) {
                    event.stopPropagation();
                    if (isWorldView && d.parent && d.parent.data.name !== (taxonomyData?.name || 'Tech Skills')) {
                        drillDown(d.parent.data);
                    }
                })
                .on('mouseover', function (event, d) {
                    d3.select(this).attr('opacity', 1).attr('stroke-width', 3);
                    const tooltip = document.getElementById('tooltip');
                    tooltip.style.display = 'block';

                    const domainName = d.parent ? d.parent.data.name : (d?.data?.__domain || '');
                    const skillKey = d?.data?.__skillKey || makeSkillKey(domainName, d?.data?.name || '');
                    const totalValue = root?.value || 1;
                    const percentage = ((d.value || 0) / totalValue * 100).toFixed(1);

                    if (isPeopleModeEnabled()) {
                        const metrics = getSelectionMetricsForSkillKey(skillKey);
                        const usageAvg = Math.round(metrics.usageAvg);
                        tooltip.innerHTML = `
                            <strong>${d.data.name} (${domainName})</strong>
                            <div>Selected unlocked (sum): ${metrics.unlockedSum}</div>
                            <div>Avg usage (selected): ${usageAvg}</div>
                            <div>% of selected total (unlocked sum): ${percentage}%</div>
                            ${metrics.selectedCount === 0 ? '<div style="margin-top: 4px; font-style: italic;">No people selected</div>' : ''}
                        `;
                    } else {
                        const { unlocked, total } = getSubSkillCounts(d.data);
                        const usage = getUsageValue(d.data);
                        tooltip.innerHTML = `
                            <strong>${d.data.name} (${domainName})</strong>
                            <div>Unlocked sub-skills: ${unlocked}/${total}</div>
                            <div>Usage frequency: ${usage}</div>
                            <div>% of Total (unlocked): ${percentage}%</div>
                        `;
                    }

                    positionTooltip(event, tooltip);
                })
                .on('mousemove', function (event) {
                    const tooltip = document.getElementById('tooltip');
                    if (tooltip?.style?.display === 'block') positionTooltip(event, tooltip);
                })
                .on('mouseout', function () {
                    const tooltip = document.getElementById('tooltip');
                    tooltip.style.display = 'none';
                    applySelectionStyles(svg);
                });

            // Domain borders in overview (removed per request)
            if (isWorldView) {
                g.selectAll('.domain-border')
                    .data(domains)
                    .join('path')
                    .attr('class', 'domain-border')
                    .attr('d', d => d.polygon ? "M" + d.polygon.join("L") + "Z" : null)
                    .attr('fill', 'none')
                    .attr('stroke', 'none')
                    .attr('stroke-width', 0)
                    .style('pointer-events', 'none');
            }

            // Labels
            g.selectAll('.skill-label')
                .data(leaves)
                .join('text')
                .attr('class', 'skill-label')
                .attr('x', d => d.polygon ? d3.polygonCentroid(d.polygon)[0] : 0)
                .attr('y', d => d.polygon ? d3.polygonCentroid(d.polygon)[1] : 0)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('fill', '#fff')
                .attr('font-size', d => {
                    if (!d.polygon) return '10px';
                    const area = Math.abs(d3.polygonArea(d.polygon));
                    return Math.max(8, Math.min(18, Math.sqrt(area) / 10)) + 'px';
                })
                .attr('font-weight', 'bold')
                .style('pointer-events', 'none')
                .text(d => {
                    if (!d.polygon) return '';
                    const area = Math.abs(d3.polygonArea(d.polygon));
                    const name = d.data.name;
                    if (area > 8000) return name;
                    if (area > 4000) return name.length > 10 ? name.substring(0, 10) : name;
                    if (area > 2000) return name.length > 6 ? name.substring(0, 6) : name;
                    return '';
                });

            svg.on('click', () => {
                if (history.length > 0) goBack();
            });

            applySelectionStyles(svg);
            updateControls();
        }

        function drillDown(data) {
            history.push(currentData);
            currentData = data;
            renderChart(currentData);
        }

        function goBack() {
            if (history.length > 0) {
                currentData = history.pop();
                renderChart(currentData);
            }
        }

        function reset() {
            currentData = taxonomyData;
            history = [];
            renderChart(currentData);
        }

        function updateControls() {
            const controls = document.getElementById('controls');
            const breadcrumb = document.getElementById('breadcrumb');
            const mainTitle = document.getElementById('mainTitle');
            const subtitle = document.getElementById('subtitle');

            if (currentData !== taxonomyData || history.length > 0) {
                controls.style.display = 'flex';
                breadcrumb.textContent = currentData !== taxonomyData ? `Current: ${currentData.name}` : '';
                mainTitle.textContent = `Programming Skills Map`;
                subtitle.textContent = 'Method 1: dynamic geometry (areas recomputed per selection)';
            } else {
                controls.style.display = 'none';
                mainTitle.textContent = 'Programming Skills Map';
                subtitle.textContent = 'Method 1: dynamic geometry (areas recomputed per selection)';
            }
        }

        function scheduleRender() {
            if (renderDebounceTimer) window.clearTimeout(renderDebounceTimer);
            renderDebounceTimer = window.setTimeout(() => {
                renderDebounceTimer = null;
                renderChart(currentData);
            }, 80);
        }

        function initPeopleUI(people) {
            const panel = document.getElementById('peoplePanel');
            const list = document.getElementById('peopleList');
            const selectAllBtn = document.getElementById('selectAllPeopleBtn');
            const clearBtn = document.getElementById('clearPeopleBtn');
            const searchInput = document.getElementById('peopleSearch');

            if (!panel || !list || !selectAllBtn || !clearBtn) return;

            const persons = Array.isArray(people) ? people : [];
            if (persons.length === 0) {
                panel.style.display = 'none';
                return;
            }

            panel.style.display = 'block';
            list.innerHTML = '';
            if (searchInput) searchInput.value = '';

            // Default: all selected
            selectedPersonIds = new Set(persons.map(p => String(p?.id || '').trim()).filter(Boolean));
            updatePeopleCountLabel();

            persons.forEach(person => {
                const personId = String(person?.id || '').trim();
                if (!personId) return;
                const checkboxId = `person-${personId}`;
                const item = document.createElement('div');
                item.className = 'people-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = checkboxId;
                checkbox.checked = true;
                checkbox.addEventListener('change', () => {
                    if (checkbox.checked) selectedPersonIds.add(personId);
                    else selectedPersonIds.delete(personId);
                    updatePeopleCountLabel();
                    scheduleRender();
                });

                const label = document.createElement('label');
                label.setAttribute('for', checkboxId);
                label.textContent = person?.name ? String(person.name) : personId;

                item.appendChild(checkbox);
                item.appendChild(label);
                list.appendChild(item);
            });

            if (searchInput) {
                searchInput.addEventListener('input', () => {
                    const q = String(searchInput.value || '').trim().toLowerCase();
                    list.querySelectorAll('.people-item').forEach(item => {
                        const txt = (item.textContent || '').toLowerCase();
                        item.style.display = q === '' || txt.includes(q) ? '' : 'none';
                    });
                });
            }

            selectAllBtn.addEventListener('click', () => {
                selectedPersonIds = new Set(persons.map(p => String(p?.id || '').trim()).filter(Boolean));
                list.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true);
                updatePeopleCountLabel();
                scheduleRender();
            });

            clearBtn.addEventListener('click', () => {
                selectedPersonIds = new Set();
                list.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
                updatePeopleCountLabel();
                scheduleRender();
            });
        }

        function extractBaseTaxonomyFromIndexHtml(indexHtmlText) {
            const marker = 'const baseTaxonomy =';
            const idx = indexHtmlText.indexOf(marker);
            if (idx === -1) throw new Error('Could not find baseTaxonomy in index.html');
            const after = indexHtmlText.slice(idx + marker.length);
            const braceStart = after.indexOf('{');
            if (braceStart === -1) throw new Error('Could not find { for baseTaxonomy');

            const startPos = idx + marker.length + braceStart;
            let depth = 0;
            let inStr = false;
            let strQuote = '';
            for (let i = startPos; i < indexHtmlText.length; i++) {
                const ch = indexHtmlText[i];
                const prev = indexHtmlText[i - 1];
                if (inStr) {
                    if (ch === strQuote && prev !== '\\\\') {
                        inStr = false;
                        strQuote = '';
                    }
                    continue;
                }
                if (ch === "'" || ch === '"' || ch === '`') {
                    inStr = true;
                    strQuote = ch;
                    continue;
                }
                if (ch === '{') depth += 1;
                if (ch === '}') depth -= 1;
                if (depth === 0) {
                    const objText = indexHtmlText.slice(startPos, i + 1);
                    // Evaluate trusted local content (same repo file)
                    // eslint-disable-next-line no-new-func
                    return (new Function(`return (${objText});`))();
                }
            }
            throw new Error('Unterminated baseTaxonomy object');
        }

        async function initApp() {
            // Load taxonomy from method2 page to keep them in sync without duplicating the big object.
            try {
                const indexText = await fetch('./index.html', { cache: 'no-store' }).then(r => r.text());
                baseTaxonomy = extractBaseTaxonomyFromIndexHtml(indexText);
            } catch (e) {
                console.warn('Failed to load baseTaxonomy from index.html, using empty taxonomy:', e);
                baseTaxonomy = { name: 'Tech Skills', children: [] };
            }

            taxonomyData = cloneObject(baseTaxonomy);
            currentData = taxonomyData;
            history = [];

            try {
                const resp = await fetch('./people.json', { cache: 'no-store' });
                if (!resp.ok) throw new Error(`Failed to load people.json (${resp.status})`);
                peopleData = await resp.json();
                const persons = Array.isArray(peopleData?.people) ? peopleData.people : [];

                applyPeopleUnionToTaxonomy(taxonomyData, persons);
                annotateAndIndexTaxonomy(taxonomyData);
                buildPeopleMetrics(persons);
                initPeopleUI(persons);
            } catch (err) {
                console.warn('People mode disabled:', err);
                peopleData = null;
                selectedPersonIds = new Set();
                const panel = document.getElementById('peoplePanel');
                if (panel) panel.style.display = 'none';
                annotateAndIndexTaxonomy(taxonomyData);
            }

            renderChart(currentData);
        }

        initApp();
    </script>
</body>

</html>
