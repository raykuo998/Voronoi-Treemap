<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programming Skills Map - Interactive Skill Tree</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            color: rgba(255, 255, 255, 0.9);
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.1rem;
        }

        .method-badge {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            display: inline-block;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            display: none;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .people-panel {
            background: white;
            padding: 16px 18px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            margin-bottom: 16px;
            display: none;
        }

        .people-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .people-search {
            flex: 1 1 240px;
            max-width: 420px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .people-search input[type="text"] {
            width: 100%;
            padding: 9px 10px;
            border-radius: 10px;
            border: 1px solid rgba(0, 0, 0, 0.12);
            outline: none;
            font-size: 13px;
            font-weight: 600;
            color: #333;
            background: rgba(0, 0, 0, 0.02);
        }

        .people-search input[type="text"]:focus {
            border-color: rgba(102, 126, 234, 0.7);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.15);
            background: white;
        }

        .people-panel-title {
            font-weight: 800;
            color: #333;
            font-size: 14px;
            letter-spacing: 0.02em;
        }

        .people-panel-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .people-panel-actions button {
            padding: 8px 12px;
            font-size: 13px;
        }

        .people-count {
            color: #666;
            font-size: 13px;
            font-weight: 600;
        }

        .people-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 360px;
            overflow: auto;
            padding-right: 6px;
        }

        .person-item {
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            padding: 12px 16px;
            border-radius: 10px;
            border: 1px solid rgba(0, 0, 0, 0.08);
            background: #fff;
            transition: background 150ms ease;
        }

        .person-item:hover {
            background: rgba(102, 126, 234, 0.06);
        }

        .person-checkbox {
            width: 18px;
            height: 18px;
            flex: 0 0 auto;
            cursor: pointer;
        }

        .person-avatar,
        .person-avatar-fallback {
            width: 28px;
            height: 28px;
            border-radius: 999px;
            flex: 0 0 auto;
        }

        .person-avatar {
            object-fit: cover;
            background: rgba(0, 0, 0, 0.05);
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.08);
        }

        .person-avatar-fallback {
            display: grid;
            place-items: center;
            font-size: 11px;
            font-weight: 800;
            letter-spacing: 0.04em;
            color: rgba(0, 0, 0, 0.65);
            background: rgba(102, 126, 234, 0.12);
            border: 1px solid rgba(0, 0, 0, 0.06);
        }

        .person-name {
            min-width: 0;
            flex: 1 1 auto;
            font-size: 14px;
            font-weight: 500;
            color: #333;
        }

        .person-details-btn {
            flex: 0 0 auto;
            padding: 6px 10px;
            font-size: 12px;
            font-weight: 700;
            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            background: rgba(102, 126, 234, 0.08);
            color: #3344aa;
            cursor: pointer;
        }

        .person-details-btn:hover {
            background: rgba(102, 126, 234, 0.14);
        }

        body.people-details-open {
            overflow: hidden;
        }

        .people-details-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.38);
            display: none;
            align-items: stretch;
            justify-content: flex-end;
            z-index: 1000;
        }

        .people-details-backdrop[data-open="1"] {
            display: flex;
        }

        .people-details-drawer {
            width: min(560px, 94vw);
            height: 100%;
            background: #fff;
            box-shadow: -12px 0 30px rgba(0, 0, 0, 0.18);
            display: flex;
            flex-direction: column;
        }

        .people-details-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 14px 16px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        .people-details-title {
            font-weight: 900;
            color: #333;
            font-size: 14px;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .people-details-close {
            flex: 0 0 auto;
            width: 34px;
            height: 34px;
            border-radius: 10px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            background: rgba(0, 0, 0, 0.03);
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            color: #444;
        }

        .people-details-close:hover {
            background: rgba(0, 0, 0, 0.06);
        }

        .people-details-body {
            padding: 14px 16px;
            overflow: auto;
        }

        .person-section {
            display: grid;
            gap: 8px;
        }

        .person-section+.person-section {
            margin-top: 14px;
        }

        .person-section-title {
            color: #667eea;
            font-weight: 900;
            font-size: 12px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .person-skill-list,
        .person-reco-list {
            display: grid;
            gap: 8px;
        }

        .person-skill-row,
        .person-reco-row {
            padding: 10px 10px;
            border-radius: 10px;
            border: 1px solid rgba(0, 0, 0, 0.06);
            background: rgba(102, 126, 234, 0.04);
        }

        .person-skill-row {
            display: grid;
            grid-template-columns: 1fr auto;
            grid-template-rows: auto auto;
            gap: 6px 12px;
        }

        .person-reco-row {
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: auto auto;
            gap: 8px;
        }

        .person-skill-main {
            min-width: 0;
        }

        .person-skill-name,
        .person-reco-name {
            font-weight: 900;
            color: #333;
            font-size: 13px;
            line-height: 1.2;
        }

        .person-skill-sub,
        .person-reco-sub {
            margin-top: 2px;
            color: rgba(0, 0, 0, 0.55);
            font-weight: 700;
            font-size: 12px;
            line-height: 1.2;
        }

        .person-reco-hint {
            margin-top: 6px;
            color: rgba(0, 0, 0, 0.45);
            font-weight: 700;
            font-size: 12px;
            line-height: 1.3;
        }

        .person-reco-reason {
            grid-column: 1 / -1;
            margin-top: 4px;
            color: rgba(0, 0, 0, 0.52);
            font-weight: 700;
            font-size: 12px;
            line-height: 1.35;
            white-space: pre-line;
        }

        .person-skill-stat {
            font-variant-numeric: tabular-nums;
            font-weight: 900;
            color: #333;
            font-size: 12px;
            white-space: nowrap;
        }

        .person-skill-bar {
            grid-column: 1 / -1;
            height: 8px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.08);
            overflow: hidden;
        }

        .person-skill-bar-fill {
            height: 100%;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.35), rgba(102, 126, 234, 0.95));
        }

        .person-empty {
            color: #666;
            font-size: 13px;
            line-height: 1.4;
            padding: 2px 2px;
        }

        button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.6);
        }

        button:active {
            transform: translateY(0);
        }

        .back-btn {
            background: #6c757d;
        }

        .back-btn:hover {
            background: #5a6268;
        }

        .breadcrumb {
            color: #333;
            font-size: 14px;
            font-weight: 500;
        }

        .chart-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            padding: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .toplists {
            margin-top: 14px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .toplist-card {
            background: rgba(255, 255, 255, 0.92);
            border: 1px solid rgba(0, 0, 0, 0.06);
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
            padding: 14px 16px;
        }

        .toplist-title {
            text-align: center;
            color: #667eea;
            font-weight: 800;
            font-size: 12px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .toplist-list {
            list-style: none;
            padding-left: 0;
            margin: 0;
            display: grid;
            gap: 8px;
        }

        .toplist-item {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 10px;
            padding: 8px 10px;
            border-radius: 10px;
            background: rgba(102, 126, 234, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.04);
        }

        .toplist-skill {
            font-weight: 800;
            color: #333;
            font-size: 13px;
            line-height: 1.2;
        }

        .toplist-domain {
            display: block;
            margin-top: 2px;
            color: rgba(0, 0, 0, 0.55);
            font-weight: 700;
            font-size: 12px;
        }

        .toplist-stat {
            font-variant-numeric: tabular-nums;
            color: #333;
            font-weight: 800;
            font-size: 12px;
            white-space: nowrap;
        }

        .toplist-empty {
            color: #666;
            font-size: 13px;
            line-height: 1.5;
            text-align: center;
            padding: 10px 6px;
        }

        .tooltip {
            position: fixed;
            display: none;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            pointer-events: none;
            z-index: 1000;
            max-width: 250px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            line-height: 1.6;
            backdrop-filter: blur(10px);
        }

        .tooltip strong {
            display: block;
            margin-bottom: 6px;
            font-size: 15px;
            color: #fff;
        }

        .instructions {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
        }

        .instructions h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        .instructions ul {
            list-style: none;
            padding-left: 0;
        }

        .instructions li {
            padding: 8px 0;
            color: #666;
            font-size: 14px;
        }

        .instructions li::before {
            content: "‚úì ";
            color: #667eea;
            font-weight: bold;
            margin-right: 8px;
        }

        .instructions h4 {
            color: #333;
            margin-top: 15px;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .instructions ol {
            list-style-position: inside;
            padding-left: 0;
        }

        .instructions ol li {
            padding: 8px 0;
        }

        .instructions ol li::before {
            content: "";
            margin-right: 0;
        }

        .instructions ul ul {
            margin-top: 5px;
            margin-bottom: 5px;
            padding-left: 20px;
        }

        .instructions ul ul li::before {
            content: "‚óã ";
        }

        .instructions pre {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 10px 0;
        }

        .instructions code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #d63384;
        }

        .instructions pre code {
            background: transparent;
            padding: 0;
            color: #333;
        }

        .instructions strong {
            color: #667eea;
        }

        /* Legend block (under the chart) */
        .legend-card {
            background: rgba(255, 255, 255, 0.92);
            border: 1px solid rgba(0, 0, 0, 0.06);
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
            padding: 14px 16px;
            margin-top: 12px;
        }

        .legend-title {
            text-align: center;
            color: #667eea;
            font-weight: 800;
            font-size: 12px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .legend-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 260px;
        }

        .legend-divider {
            width: 1px;
            height: 36px;
            background: rgba(0, 0, 0, 0.08);
        }

        .legend-icon-size {
            display: flex;
            align-items: flex-end;
            gap: 8px;
        }

        .legend-dot {
            display: inline-block;
            border-radius: 999px;
            background: #667eea;
            opacity: 0.75;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.8);
        }

        .legend-dot.dot-sm {
            width: 10px;
            height: 10px;
        }

        .legend-dot.dot-lg {
            width: 18px;
            height: 18px;
        }

        .legend-icon-gradient {
            width: 96px;
            height: 14px;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.18), rgba(102, 126, 234, 0.95));
            border: 1px solid rgba(0, 0, 0, 0.08);
        }

        .legend-label {
            font-weight: 800;
            color: #333;
            font-size: 13px;
            line-height: 1.1;
        }

        .legend-desc {
            color: #666;
            font-size: 13px;
            line-height: 1.35;
            margin-top: 2px;
        }

        .legend-sub {
            text-align: center;
            color: rgba(0, 0, 0, 0.55);
            font-size: 12px;
            margin-top: 10px;
            line-height: 1.4;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .toplists {
                grid-template-columns: 1fr;
            }

            button {
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1 id="mainTitle">üíª Programming Skills Map</h1>
        <p class="subtitle" id="subtitle">Skills grouped by domain - Interactive skill tree visualization</p>
        <div style="text-align: center;">
            <span class="method-badge">üéØ Skill Map: Competencies within Technical Domains</span>
        </div>

        <div class="controls" id="controls">
            <button class="back-btn" id="backBtn" onclick="goBack()">‚Üê Back</button>
            <button id="resetBtn" onclick="reset()">‚åÇ Reset to Overview</button>
            <span class="breadcrumb" id="breadcrumb"></span>
        </div>

        <div class="chart-container">
            <svg id="chart"></svg>
        </div>

        <div class="toplists" id="toplists">
            <div class="toplist-card">
                <div class="toplist-title">Top 5 Most proficient skills</div>
                <ul class="toplist-list" id="topMostList"></ul>
                <div class="toplist-empty" id="topMostEmpty" style="display:none;"></div>
            </div>
            <div class="toplist-card">
                <div class="toplist-title">Top 5 Least proficient skills</div>
                <ul class="toplist-list" id="topLeastList"></ul>
                <div class="toplist-empty" id="topLeastEmpty" style="display:none;"></div>
            </div>
        </div>

        <div class="people-panel" id="peoplePanel">
            <div class="people-panel-header">
                <div class="people-panel-title">People</div>
                <div class="people-search">
                    <input type="text" id="peopleSearch" placeholder="Search people..." />
                </div>
                <div class="people-panel-actions">
                    <span class="people-count" id="peopleCount"></span>
                    <button type="button" id="selectAllPeopleBtn">Select all</button>
                    <button type="button" class="back-btn" id="clearPeopleBtn">Clear</button>
                </div>
            </div>
            <div class="people-list" id="peopleList"></div>
        </div>

        <div class="people-details-backdrop" id="peopleDetailsBackdrop" data-open="0" aria-hidden="true">
            <div class="people-details-drawer" role="dialog" aria-modal="true" aria-labelledby="peopleDetailsTitle">
                <div class="people-details-header">
                    <div class="people-details-title" id="peopleDetailsTitle">Details</div>
                    <button type="button" class="people-details-close" id="peopleDetailsCloseBtn"
                        aria-label="Close details">√ó</button>
                </div>
                <div class="people-details-body" id="peopleDetailsBody"></div>
            </div>
        </div>

        <div class="legend-card">
            <div class="legend-title">Legend</div>
            <div class="legend-row">
                <div class="legend-item">
                    <div class="legend-icon-size" aria-hidden="true">
                        <span class="legend-dot dot-sm"></span>
                        <span class="legend-dot dot-lg"></span>
                    </div>
                    <div>
                        <div class="legend-label">Size</div>
                        <div class="legend-desc">How well I know this skill</div>
                    </div>
                </div>
                <div class="legend-divider" aria-hidden="true"></div>
                <div class="legend-item">
                    <div class="legend-icon-gradient" aria-hidden="true"></div>
                    <div>
                        <div class="legend-label">Color intensity</div>
                        <div class="legend-desc">How frequent (proficient) I use this skill</div>
                    </div>
                </div>
            </div>
            <div class="legend-sub">
                Area represents number of unlocked sub-skills ‚Ä¢ Color intensity represents usage frequency
            </div>
        </div>

        <div class="instructions">
            <h3>Skill Map Features</h3>
            <ul>
                <li>All skills displayed in the root view</li>
                <li>Skills from the same domain grouped into contiguous regions (roadmap.sh-style)</li>
                <li>Domains calculated first, then skills distributed within regions</li>
                <li>Click any skill to zoom into its domain view</li>
                <li>Area represents number of unlocked sub-skills</li>
                <li>Color intensity represents usage frequency</li>
            </ul>
        </div>

        <div class="instructions">
            <h3>üîß Technical Implementation</h3>
            <p style="color: #666; margin-bottom: 15px;">roadmap.sh-style visualization using weighted Voronoi Treemap
                with domain grouping.</p>

            <h4>üíº Four-Domain Grouping Strategy:</h4>
            <ul>
                <li><strong>Why domain grouping?</strong> Creates clear skill clusters by technical area, similar to
                    roadmap.sh's domain organization</li>
                <li><strong>Selected domains:</strong>
                    <ul>
                        <li><strong>Frontend</strong> - UI/UX technologies (React, Vue, TypeScript, etc.)</li>
                        <li><strong>Backend</strong> - Server-side tech (Node.js, Python, databases, etc.)</li>
                        <li><strong>DevOps</strong> - Infrastructure & deployment (Docker, K8s, AWS, etc.)</li>
                        <li><strong>Mobile</strong> - Mobile development (React Native, Flutter, Swift, etc.)</li>
                    </ul>
                </li>
                <li><strong>Data structure:</strong> Two-level hierarchy - domains as parent nodes, skills as leaf nodes
                </li>
            </ul>

            <h4>üéØ roadmap.sh-Style Effect Implementation:</h4>
            <ul>
                <li><strong>Step 1 - Domain Voronoi:</strong> Calculate 4 large domain polygons using weighted treemap
                    <ul>
                        <li>Each domain gets area proportional to its total unlocked sub-skills</li>
                        <li>Creates distinct regional boundaries (like roadmap.sh's skill groupings)</li>
                    </ul>
                </li>
                <li><strong>Step 2 - Nested Skill Distribution:</strong> Within each domain polygon, distribute skills
                    <ul>
                        <li>Skills only appear within their parent domain's boundary</li>
                        <li>Maintains visual grouping - all Frontend skills cluster together</li>
                        <li>Similar to how roadmap.sh groups related technologies</li>
                    </ul>
                </li>
                <li><strong>Step 3 - Domain Borders:</strong> Draw thick borders (#333, 3px) around domain polygons
                    <ul>
                        <li>Creates clear visual separation between technical domains</li>
                        <li>Labels placed outside circle using polygon centroids</li>
                    </ul>
                </li>
            </ul>

            <h4>‚öôÔ∏è Core Algorithm:</h4>
            <pre><code>// 1. Create hierarchical skill data structure
const skillData = {
    name: "Tech Skills",
    children: [
        { name: "Frontend", children: [/* React, Vue, etc. */] },
        { name: "Backend", children: [/* Node.js, Python, etc. */] },
        { name: "DevOps", children: [/* Docker, K8s, etc. */] },
        { name: "Mobile", children: [/* React Native, Flutter, etc. */] }
    ]
};

// 2. Apply weighted Voronoi treemap
const voronoiTreemap = d3.voronoiTreemap()
    .clip(circlePolygon)              // Clip to circular boundary
    .convergenceRatio(0.001)          // 0.1% accuracy threshold
    .maxIterationCount(100)           // Max optimization iterations
    .minWeightRatio(0.001);           // Min cell size threshold

voronoiTreemap(root);                 // Calculates BOTH levels simultaneously

// 3. Result: root.children[] = domains with polygons
//            root.leaves() = skills with polygons
//    Each skill.polygon is automatically CLIPPED to its parent domain!</code></pre>

            <h4>üîë Key Difference from Standard Approach:</h4>
            <ul>
                <li><strong>‚ùå Standard Voronoi (d3.Delaunay):</strong> Flat structure, countries distributed by seed
                    point distance only
                    <ul>
                        <li>No weight consideration ‚Üí incorrect proportions</li>
                        <li>No grouping ‚Üí countries scatter randomly</li>
                        <li>Result: Fragmented, no regional patterns</li>
                    </ul>
                </li>
                <li><strong>‚úÖ Weighted Voronoi Treemap:</strong> Hierarchical structure with area-proportional
                    distribution
                    <ul>
                        <li>Respects parent-child hierarchy ‚Üí natural grouping</li>
                        <li>Iterative adjustment ‚Üí accurate area matching</li>
                        <li>Result: Clean regional clusters (NATO-style)</li>
                    </ul>
                </li>
            </ul>

            <h4>üêõ Critical Bug Fixes:</h4>
            <ol>
                <li><strong>Area proportionality failure:</strong>
                    <ul>
                        <li><strong>Symptom:</strong> High-weight items appearing smaller than low-weight items</li>
                        <li><strong>Cause:</strong> Used <code>d3.Delaunay</code> which ignores weights</li>
                        <li><strong>Evidence from logs:</strong> Expected vs actual area mismatch (35.7% ‚Üí 8.6%)</li>
                        <li><strong>Fix:</strong> Replaced with <code>d3.voronoiTreemap()</code></li>
                        <li><strong>Result:</strong> Areas now correctly match weight proportions</li>
                    </ul>
                </li>
                <li><strong>Domain labels positioned at origin (0,0):</strong>
                    <ul>
                        <li><strong>Symptom:</strong> All 4 domain labels stuck in top-left corner</li>
                        <li><strong>Cause:</strong> <code>voronoiTreemap()</code> doesn't preserve <code>x/y</code>
                            coordinates from pack layout</li>
                        <li><strong>Evidence from logs:</strong>
                            <code>{"x":undefined,"y":undefined,"angle":null,"labelX":null}</code>
                        </li>
                        <li><strong>Fix:</strong> Changed to use <code>d3.polygonCentroid(domain.polygon)</code> for
                            angle calculation</li>
                        <li><strong>Result:</strong> Labels correctly distributed around circle perimeter</li>
                    </ul>
                </li>
            </ol>

            <h4>üìö Required Dependencies:</h4>
            <ul>
                <li><code>d3@7</code> - Core visualization library</li>
                <li><code>d3-weighted-voronoi@1</code> - <strong>Critical:</strong> Required by d3-voronoi-treemap</li>
                <li><code>d3-voronoi-map@2</code> - Base Voronoi mapping utilities</li>
                <li><code>d3-voronoi-treemap@1</code> - Hierarchical weighted Voronoi implementation</li>
            </ul>
            <p style="color: #d63384; margin-top: 10px; font-size: 13px;">
                ‚ö†Ô∏è <strong>Important:</strong> Missing <code>d3-weighted-voronoi</code> will cause error:
                <code>"i.weightedVoronoi is not a function"</code>
            </p>

            <h4>‚ö° Performance Notes:</h4>
            <ul>
                <li>Initial calculation: ~2-3 seconds for 33 skills across 4 domains</li>
                <li>Iterative algorithm may run up to 100 iterations to achieve convergence</li>
                <li>Convergence ratio of 0.001 ensures area accuracy within 0.1%</li>
                <li>Use 64-point polygon for smooth circular clipping</li>
            </ul>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-weighted-voronoi@1"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-voronoi-map@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-voronoi-treemap@1"></script>
    <script>
        if (typeof d3 === 'undefined') {
            document.body.innerHTML = '<div style="text-align:center;padding:50px;"><h2>‚ö†Ô∏è D3.js Failed to Load</h2><p>Please check your internet connection</p></div>';
            throw new Error('D3.js failed to load');
        }
    </script>

    <script>
        // Base taxonomy (skill names + sub-skill names).
        // Multi-person mode loads per-person values from people.json.
        const baseTaxonomy = {
            name: "Tech Skills",
            children: [
                {
                    name: "Frontend",
                    children: [
                        {
                            name: "React",
                            usage: 95,
                            subSkills: [
                                { name: "Hooks", unlocked: true },
                                { name: "State management", unlocked: true },
                                { name: "Routing", unlocked: true },
                                { name: "Testing", unlocked: false },
                                { name: "Performance", unlocked: false }
                            ]
                        },
                        {
                            name: "Vue.js",
                            usage: 60,
                            subSkills: [
                                { name: "Composition API", unlocked: true },
                                { name: "Options API", unlocked: true },
                                { name: "Routing", unlocked: false },
                                { name: "State (Pinia)", unlocked: false }
                            ]
                        },
                        {
                            name: "TypeScript",
                            usage: 88,
                            subSkills: [
                                { name: "Types & interfaces", unlocked: true },
                                { name: "Generics", unlocked: true },
                                { name: "Type narrowing", unlocked: true },
                                { name: "Advanced utility types", unlocked: false }
                            ]
                        },
                        {
                            name: "Angular",
                            usage: 35,
                            subSkills: [
                                { name: "Components", unlocked: true },
                                { name: "RxJS", unlocked: false },
                                { name: "Forms", unlocked: false }
                            ]
                        },
                        {
                            name: "CSS/SASS",
                            usage: 75,
                            subSkills: [
                                { name: "Layout (Flex/Grid)", unlocked: true },
                                { name: "Responsive design", unlocked: true },
                                { name: "Animations", unlocked: false },
                                { name: "Design systems", unlocked: false }
                            ]
                        },
                        {
                            name: "Webpack",
                            usage: 20,
                            subSkills: [
                                { name: "Loaders", unlocked: true },
                                { name: "Plugins", unlocked: false }
                            ]
                        },
                        {
                            name: "Next.js",
                            usage: 55,
                            subSkills: [
                                { name: "Routing", unlocked: true },
                                { name: "Server components", unlocked: false },
                                { name: "Data fetching", unlocked: false }
                            ]
                        },
                        {
                            name: "Tailwind",
                            usage: 65,
                            subSkills: [
                                { name: "Utility workflow", unlocked: true },
                                { name: "Config & theme", unlocked: false },
                                { name: "Component patterns", unlocked: false }
                            ]
                        },
                        {
                            name: "Redux",
                            usage: 30,
                            subSkills: [
                                { name: "Core concepts", unlocked: true },
                                { name: "Redux Toolkit", unlocked: false },
                                { name: "Middleware", unlocked: false }
                            ]
                        },
                        {
                            name: "Jest",
                            usage: 45,
                            subSkills: [
                                { name: "Unit tests", unlocked: true },
                                { name: "Mocks", unlocked: false },
                                { name: "Coverage", unlocked: false }
                            ]
                        }
                    ]
                },
                {
                    name: "Backend",
                    children: [
                        {
                            name: "Node.js",
                            usage: 85,
                            subSkills: [
                                { name: "Async patterns", unlocked: true },
                                { name: "Streams", unlocked: false },
                                { name: "Testing", unlocked: false },
                                { name: "Performance", unlocked: false }
                            ]
                        },
                        {
                            name: "Python",
                            usage: 70,
                            subSkills: [
                                { name: "Core syntax", unlocked: true },
                                { name: "Packaging", unlocked: false },
                                { name: "Asyncio", unlocked: false },
                                { name: "Typing", unlocked: false }
                            ]
                        },
                        {
                            name: "Java",
                            usage: 40,
                            subSkills: [
                                { name: "OOP", unlocked: true },
                                { name: "Spring basics", unlocked: false },
                                { name: "JVM tuning", unlocked: false }
                            ]
                        },
                        {
                            name: "Go",
                            usage: 25,
                            subSkills: [
                                { name: "Goroutines", unlocked: true },
                                { name: "Channels", unlocked: false }
                            ]
                        },
                        {
                            name: "PostgreSQL",
                            usage: 60,
                            subSkills: [
                                { name: "Schema design", unlocked: true },
                                { name: "Indexes", unlocked: true },
                                { name: "Query tuning", unlocked: false }
                            ]
                        },
                        {
                            name: "MongoDB",
                            usage: 30,
                            subSkills: [
                                { name: "Documents", unlocked: true },
                                { name: "Aggregation", unlocked: false }
                            ]
                        },
                        {
                            name: "Redis",
                            usage: 35,
                            subSkills: [
                                { name: "Caching", unlocked: true },
                                { name: "Data structures", unlocked: false }
                            ]
                        },
                        {
                            name: "GraphQL",
                            usage: 20,
                            subSkills: [
                                { name: "Schemas", unlocked: true },
                                { name: "Resolvers", unlocked: false }
                            ]
                        },
                        {
                            name: "REST API",
                            usage: 80,
                            subSkills: [
                                { name: "Routing", unlocked: true },
                                { name: "Auth patterns", unlocked: true },
                                { name: "Pagination", unlocked: false },
                                { name: "Versioning", unlocked: false }
                            ]
                        }
                    ]
                },
                {
                    name: "DevOps",
                    children: [
                        {
                            name: "Docker",
                            usage: 65,
                            subSkills: [
                                { name: "Images & layers", unlocked: true },
                                { name: "Compose", unlocked: true },
                                { name: "Networking", unlocked: false }
                            ]
                        },
                        {
                            name: "Kubernetes",
                            usage: 30,
                            subSkills: [
                                { name: "Deployments", unlocked: true },
                                { name: "Services", unlocked: false },
                                { name: "Ingress", unlocked: false }
                            ]
                        },
                        {
                            name: "AWS",
                            usage: 40,
                            subSkills: [
                                { name: "EC2/VPC basics", unlocked: true },
                                { name: "S3", unlocked: true },
                                { name: "IAM", unlocked: false }
                            ]
                        },
                        {
                            name: "CI/CD",
                            usage: 55,
                            subSkills: [
                                { name: "Pipelines", unlocked: true },
                                { name: "Testing stages", unlocked: false },
                                { name: "Artifacts", unlocked: false }
                            ]
                        },
                        {
                            name: "Terraform",
                            usage: 15,
                            subSkills: [
                                { name: "State & modules", unlocked: true },
                                { name: "Best practices", unlocked: false }
                            ]
                        },
                        {
                            name: "Nginx",
                            usage: 25,
                            subSkills: [
                                { name: "Reverse proxy", unlocked: true },
                                { name: "TLS basics", unlocked: false }
                            ]
                        },
                        {
                            name: "Jenkins",
                            usage: 10,
                            subSkills: [
                                { name: "Jobs", unlocked: true },
                                { name: "Agents", unlocked: false }
                            ]
                        },
                        {
                            name: "Git",
                            usage: 90,
                            subSkills: [
                                { name: "Branching", unlocked: true },
                                { name: "Rebase", unlocked: true },
                                { name: "Conflicts", unlocked: true },
                                { name: "Hooks", unlocked: false }
                            ]
                        }
                    ]
                },
                {
                    name: "Mobile",
                    children: [
                        {
                            name: "React Native",
                            usage: 35,
                            subSkills: [
                                { name: "Navigation", unlocked: true },
                                { name: "Native modules", unlocked: false },
                                { name: "Performance", unlocked: false }
                            ]
                        },
                        {
                            name: "Flutter",
                            usage: 25,
                            subSkills: [
                                { name: "Widgets", unlocked: true },
                                { name: "State mgmt", unlocked: false }
                            ]
                        },
                        {
                            name: "Swift",
                            usage: 15,
                            subSkills: [
                                { name: "UIKit/SwiftUI basics", unlocked: true },
                                { name: "Concurrency", unlocked: false }
                            ]
                        },
                        {
                            name: "Kotlin",
                            usage: 18,
                            subSkills: [
                                { name: "Syntax", unlocked: true },
                                { name: "Coroutines", unlocked: false }
                            ]
                        },
                        {
                            name: "iOS Dev",
                            usage: 12,
                            subSkills: [
                                { name: "App lifecycle", unlocked: true },
                                { name: "Publishing", unlocked: false }
                            ]
                        },
                        {
                            name: "Android",
                            usage: 14,
                            subSkills: [
                                { name: "Activities", unlocked: true },
                                { name: "Jetpack basics", unlocked: false }
                            ]
                        }
                    ]
                }
            ]
        };

        const cloneObject = typeof structuredClone === 'function'
            ? structuredClone
            : (obj) => JSON.parse(JSON.stringify(obj));

        // Global variables
        let taxonomyData = cloneObject(baseTaxonomy);
        let currentData = taxonomyData;
        let history = [];
        const width = 1000;
        const height = 1000;
        const radius = Math.min(width, height) / 2 - 80;

        // Multi-person state (method 2: fixed geometry, style updates only)
        let peopleData = null;
        let selectedPersonIds = new Set();
        let peopleById = new Map(); // id -> person
        let skillKeyToMeta = new Map(); // skillKey -> { domainName, skillName, subSkillNames:Set<string> }
        let skillKeyToPerPerson = new Map(); // skillKey -> Map(personId -> { usage:number, unlockedCount:number })
        let personIdToSkillMetrics = new Map(); // personId -> Map(skillKey -> { usage:number, unlockedCount:number })
        let layoutWeightBySkillKey = new Map(); // skillKey -> number (team aggregate)
        let layoutUnlockedSumBySkillKey = new Map(); // skillKey -> number
        let usageTGlobal = () => 0.6; // (usage:number) -> t in [0,1]
        const layoutCache = new Map(); // viewKey -> { root, leaves, domains, isWorldView }
        let selectionAggBySkillKey = new Map(); // skillKey -> { usageSum, unlockedSum, unlockedPeopleCount }
        let selectionAggSelectedCount = 0;
        let teamSkillStatsBySkillKey = new Map(); // skillKey -> { haveRatio, usageAvg, haveCount, totalPeople }

        // Domain color schemes
        const domainColorSchemes = {
            'Frontend': d3.interpolateBlues,
            'Backend': d3.interpolateGreens,
            'DevOps': d3.interpolateOranges,
            'Mobile': d3.interpolatePurples
        };

        function makeSkillKey(domainName, skillName) {
            return `${domainName}::${skillName}`;
        }

        // Calculate polygon centroid
        function polygonCentroid(polygon) {
            if (!polygon || polygon.length === 0) return [0, 0];
            let x = 0, y = 0, n = polygon.length;
            for (let i = 0; i < n; i++) {
                x += polygon[i][0];
                y += polygon[i][1];
            }
            return [x / n, y / n];
        }

        // Leaf weight (area) = number of unlocked sub-skills
        function getSubSkillCounts(skill) {
            const subSkills = Array.isArray(skill?.subSkills) ? skill.subSkills : [];
            const total = subSkills.length;
            const unlocked = subSkills.reduce((acc, s) => acc + (s && s.unlocked ? 1 : 0), 0);
            return { unlocked, total };
        }

        // Color intensity = usage frequency (dummy metric)
        function getUsageValue(skill) {
            const usage = Number(skill?.usage);
            return Number.isFinite(usage) ? usage : 0;
        }

        function positionTooltip(event, tooltip) {
            if (!tooltip) return;
            const offset = 12;
            const pad = 8;

            // Tooltip is position: fixed => use viewport coords (clientX/Y)
            const clientX = Number(event?.clientX);
            const clientY = Number(event?.clientY);
            const x0 = Number.isFinite(clientX) ? clientX : 0;
            const y0 = Number.isFinite(clientY) ? clientY : 0;

            // Ensure tooltip has dimensions (content already set by caller)
            const rect = tooltip.getBoundingClientRect();

            let x = x0 + offset;
            let y = y0 + offset;

            // Flip to left/top side if overflowing
            if (x + rect.width + pad > window.innerWidth) x = x0 - rect.width - offset;
            if (y + rect.height + pad > window.innerHeight) y = y0 - rect.height - offset;

            // Clamp within viewport
            x = Math.max(pad, Math.min(window.innerWidth - rect.width - pad, x));
            y = Math.max(pad, Math.min(window.innerHeight - rect.height - pad, y));

            tooltip.style.left = Math.round(x) + 'px';
            tooltip.style.top = Math.round(y) + 'px';
        }

        function createCirclePolygon(r, points = 64) {
            const circlePolygon = [];
            for (let i = 0; i < points; i++) {
                const angle = (i / points) * 2 * Math.PI;
                circlePolygon.push([Math.cos(angle) * r, Math.sin(angle) * r]);
            }
            return circlePolygon;
        }

        function collectLeafSkills(node) {
            if (!node) return [];
            const children = node.children;
            if (Array.isArray(children)) {
                return children.flatMap(collectLeafSkills);
            }
            return [node];
        }

        // Global usage scale so color intensity stays consistent across views
        function createGlobalUsageIntensityScale(data) {
            const usageValues = collectLeafSkills(data).map(getUsageValue);
            const usageExtent = d3.extent(usageValues);
            const hasUsageRange =
                Number.isFinite(usageExtent[0]) &&
                Number.isFinite(usageExtent[1]) &&
                usageExtent[0] !== usageExtent[1];

            return hasUsageRange
                ? d3.scaleLinear().domain(usageExtent).range([0.25, 0.9]).clamp(true)
                : () => 0.6;
        }

        function createGlobalUsageIntensityScaleFromValues(values) {
            const numeric = (Array.isArray(values) ? values : [])
                .map(v => Number(v))
                .filter(v => Number.isFinite(v));
            const extent = d3.extent(numeric);
            const hasRange =
                Number.isFinite(extent[0]) &&
                Number.isFinite(extent[1]) &&
                extent[0] !== extent[1];
            return hasRange
                ? d3.scaleLinear().domain(extent).range([0.15, 0.95]).clamp(true)
                : () => 0.6;
        }

        // Clip polygon to circle
        function clipPolygonToCircle(polygon, cx, cy, r) {
            if (!polygon || polygon.length < 3) return polygon;

            const result = [];
            const n = polygon.length;

            for (let i = 0; i < n; i++) {
                const current = polygon[i];
                const next = polygon[(i + 1) % n];

                const currentInside = Math.sqrt(Math.pow(current[0] - cx, 2) + Math.pow(current[1] - cy, 2)) <= r;
                const nextInside = Math.sqrt(Math.pow(next[0] - cx, 2) + Math.pow(next[1] - cy, 2)) <= r;

                if (currentInside) {
                    result.push(current);
                }

                if (currentInside !== nextInside) {
                    // Find intersection
                    const intersection = lineCircleIntersection(current, next, cx, cy, r);
                    if (intersection) {
                        result.push(intersection);
                    }
                }
            }

            return result.length >= 3 ? result : polygon;
        }

        // Line-circle intersection
        function lineCircleIntersection(p1, p2, cx, cy, r) {
            const dx = p2[0] - p1[0];
            const dy = p2[1] - p1[1];
            const fx = p1[0] - cx;
            const fy = p1[1] - cy;

            const a = dx * dx + dy * dy;
            const b = 2 * (fx * dx + fy * dy);
            const c = fx * fx + fy * fy - r * r;

            const discriminant = b * b - 4 * a * c;
            if (discriminant < 0) return null;

            const t1 = (-b - Math.sqrt(discriminant)) / (2 * a);
            const t2 = (-b + Math.sqrt(discriminant)) / (2 * a);

            let t = null;
            if (t1 >= 0 && t1 <= 1) t = t1;
            else if (t2 >= 0 && t2 <= 1) t = t2;

            if (t === null) return null;

            return [p1[0] + t * dx, p1[1] + t * dy];
        }

        function getDomainNodeByName(taxonomy, domainName) {
            const domains = Array.isArray(taxonomy?.children) ? taxonomy.children : [];
            return domains.find(d => d && d.name === domainName) || null;
        }

        function ensureDomainNode(taxonomy, domainName) {
            if (!taxonomy) return null;
            if (!Array.isArray(taxonomy.children)) taxonomy.children = [];
            const existing = getDomainNodeByName(taxonomy, domainName);
            if (existing) return existing;
            const domainNode = { name: domainName, children: [] };
            taxonomy.children.push(domainNode);
            return domainNode;
        }

        function ensureSkillNode(domainNode, skillName) {
            if (!domainNode) return null;
            if (!Array.isArray(domainNode.children)) domainNode.children = [];
            const existing = domainNode.children.find(s => s && s.name === skillName) || null;
            if (existing) return existing;
            const skillNode = { name: skillName, usage: 0, subSkills: [] };
            domainNode.children.push(skillNode);
            return skillNode;
        }

        function ensureSubSkillNames(skillNode, names) {
            if (!skillNode) return;
            if (!Array.isArray(skillNode.subSkills)) skillNode.subSkills = [];
            const existing = new Set(skillNode.subSkills.map(s => s && s.name).filter(Boolean));
            (Array.isArray(names) ? names : []).forEach(name => {
                if (!name || existing.has(name)) return;
                skillNode.subSkills.push({ name, unlocked: false });
                existing.add(name);
            });
        }

        function applyPeopleUnionToTaxonomy(taxonomy, people) {
            const persons = Array.isArray(people) ? people : [];
            persons.forEach(person => {
                const skills = Array.isArray(person?.skills) ? person.skills : [];
                skills.forEach(rec => {
                    const domainName = String(rec?.domain || '').trim();
                    const skillName = String(rec?.skill || '').trim();
                    if (!domainName || !skillName) return;
                    const domainNode = ensureDomainNode(taxonomy, domainName);
                    const skillNode = ensureSkillNode(domainNode, skillName);
                    ensureSubSkillNames(skillNode, rec?.unlockedSubSkills);
                });
            });
        }

        function annotateAndIndexTaxonomy(taxonomy) {
            skillKeyToMeta = new Map();
            const domains = Array.isArray(taxonomy?.children) ? taxonomy.children : [];
            domains.forEach(domain => {
                const domainName = domain?.name;
                const skills = Array.isArray(domain?.children) ? domain.children : [];
                skills.forEach(skill => {
                    if (!skill || !domainName || !skill.name) return;
                    skill.__domain = domainName;
                    skill.__skillKey = makeSkillKey(domainName, skill.name);
                    const subSkillNames = new Set(
                        (Array.isArray(skill.subSkills) ? skill.subSkills : [])
                            .map(s => s && s.name)
                            .filter(Boolean)
                    );
                    skillKeyToMeta.set(skill.__skillKey, {
                        domainName,
                        skillName: skill.name,
                        subSkillNames
                    });
                });
            });
        }

        function buildPeopleMetrics(people) {
            peopleById = new Map();
            skillKeyToPerPerson = new Map();
            personIdToSkillMetrics = new Map();
            layoutUnlockedSumBySkillKey = new Map();
            layoutWeightBySkillKey = new Map();

            const persons = Array.isArray(people) ? people : [];
            const usageValues = [];

            persons.forEach(person => {
                const id = String(person?.id || '').trim();
                if (!id) return;
                peopleById.set(id, person);
                personIdToSkillMetrics.set(id, new Map());
                const skills = Array.isArray(person?.skills) ? person.skills : [];
                skills.forEach(rec => {
                    const domainName = String(rec?.domain || '').trim();
                    const skillName = String(rec?.skill || '').trim();
                    if (!domainName || !skillName) return;
                    const skillKey = makeSkillKey(domainName, skillName);
                    const usage = Number(rec?.usage);
                    const usageValue = Number.isFinite(usage) ? usage : 0;
                    const unlockedNames = Array.isArray(rec?.unlockedSubSkills) ? rec.unlockedSubSkills : [];

                    const meta = skillKeyToMeta.get(skillKey);
                    let unlockedCount = 0;
                    if (meta && meta.subSkillNames && meta.subSkillNames.size > 0) {
                        const seen = new Set();
                        unlockedNames.forEach(n => {
                            const name = String(n || '').trim();
                            if (!name || seen.has(name)) return;
                            if (meta.subSkillNames.has(name)) {
                                unlockedCount += 1;
                                seen.add(name);
                            }
                        });
                    } else {
                        unlockedCount = unlockedNames.length;
                    }

                    if (!skillKeyToPerPerson.has(skillKey)) skillKeyToPerPerson.set(skillKey, new Map());
                    skillKeyToPerPerson.get(skillKey).set(id, { usage: usageValue, unlockedCount });
                    personIdToSkillMetrics.get(id).set(skillKey, { usage: usageValue, unlockedCount });
                    usageValues.push(usageValue);
                });
            });

            // Team-aggregate layout weights: sum of unlocked counts across all people.
            for (const skillKey of skillKeyToMeta.keys()) {
                const perPerson = skillKeyToPerPerson.get(skillKey);
                let sumUnlocked = 0;
                if (perPerson) {
                    for (const v of perPerson.values()) sumUnlocked += Number(v?.unlockedCount) || 0;
                }
                layoutUnlockedSumBySkillKey.set(skillKey, sumUnlocked);
                layoutWeightBySkillKey.set(skillKey, Math.max(0.001, sumUnlocked));
            }

            // Global intensity scale across all people.
            usageTGlobal = createGlobalUsageIntensityScaleFromValues([0, ...usageValues]);

            // Layout depends on weights; invalidate cache after recomputing.
            layoutCache.clear();
        }

        function updatePeopleCountLabel() {
            const el = document.getElementById('peopleCount');
            if (!el) return;
            const total = Array.isArray(peopleData?.people) ? peopleData.people.length : 0;
            const selected = selectedPersonIds?.size || 0;
            el.textContent = total > 0 ? `Selected: ${selected} / ${total}` : '';
        }

        function isPeopleModeEnabled() {
            return Array.isArray(peopleData?.people) && peopleData.people.length > 0;
        }

        function recomputeSelectionAggregates() {
            selectionAggSelectedCount = selectedPersonIds?.size || 0;
            selectionAggBySkillKey = new Map();
            if (!isPeopleModeEnabled()) return;

            // Only add non-zero contributions (missing skills implicitly contribute 0)
            for (const personId of selectedPersonIds) {
                const perSkill = personIdToSkillMetrics.get(personId);
                if (!perSkill) continue;
                for (const [skillKey, metric] of perSkill.entries()) {
                    const usage = Number(metric?.usage) || 0;
                    const unlocked = Number(metric?.unlockedCount) || 0;
                    if (usage === 0 && unlocked === 0) continue;

                    let agg = selectionAggBySkillKey.get(skillKey);
                    if (!agg) {
                        agg = { usageSum: 0, unlockedSum: 0, unlockedPeopleCount: 0 };
                        selectionAggBySkillKey.set(skillKey, agg);
                    }

                    agg.usageSum += usage;
                    agg.unlockedSum += unlocked;
                    if (unlocked > 0) agg.unlockedPeopleCount += 1;
                }
            }
        }

        function getSelectionMetricsForSkillKey(skillKey) {
            const selectedCount = selectionAggSelectedCount;
            const agg = selectionAggBySkillKey.get(skillKey) || { usageSum: 0, unlockedSum: 0, unlockedPeopleCount: 0 };

            if (selectedCount === 0) {
                return {
                    selectedCount: 0,
                    unlockedPeopleCount: 0,
                    unlockedPeopleRatio: 0,
                    usageAvg: 0,
                    unlockedSum: 0
                };
            }

            return {
                selectedCount,
                unlockedPeopleCount: agg.unlockedPeopleCount,
                unlockedPeopleRatio: agg.unlockedPeopleCount / selectedCount,
                usageAvg: agg.usageSum / selectedCount,
                unlockedSum: agg.unlockedSum
            };
        }

        function computeTeamSkillStats(persons) {
            const people = Array.isArray(persons) ? persons : [];
            const totalPeople = people.length;
            const haveCountBySkillKey = new Map();
            const usageSumBySkillKey = new Map();

            for (const skillKey of skillKeyToMeta.keys()) {
                haveCountBySkillKey.set(skillKey, 0);
                usageSumBySkillKey.set(skillKey, 0);
            }

            people.forEach(person => {
                const personId = String(person?.id || '').trim();
                if (!personId) return;
                const perSkill = personIdToSkillMetrics.get(personId);
                if (!perSkill) return;

                for (const [skillKey, metric] of perSkill.entries()) {
                    const usage = Number(metric?.usage) || 0;
                    const unlocked = Number(metric?.unlockedCount) || 0;
                    if (!usageSumBySkillKey.has(skillKey)) usageSumBySkillKey.set(skillKey, 0);
                    usageSumBySkillKey.set(skillKey, (usageSumBySkillKey.get(skillKey) || 0) + usage);

                    if (unlocked > 0) {
                        if (!haveCountBySkillKey.has(skillKey)) haveCountBySkillKey.set(skillKey, 0);
                        haveCountBySkillKey.set(skillKey, (haveCountBySkillKey.get(skillKey) || 0) + 1);
                    }
                }
            });

            teamSkillStatsBySkillKey = new Map();
            for (const skillKey of skillKeyToMeta.keys()) {
                const haveCount = haveCountBySkillKey.get(skillKey) || 0;
                const usageSum = usageSumBySkillKey.get(skillKey) || 0;
                teamSkillStatsBySkillKey.set(skillKey, {
                    haveCount,
                    totalPeople,
                    haveRatio: totalPeople > 0 ? haveCount / totalPeople : 0,
                    usageAvg: totalPeople > 0 ? usageSum / totalPeople : 0
                });
            }
        }

        function formatPercent01(p) {
            const n = Number(p);
            if (!Number.isFinite(n)) return '0%';
            return `${Math.round(Math.max(0, Math.min(1, n)) * 100)}%`;
        }

        function getGitHubUsername(person) {
            const raw = person?.github ?? person?.githubUsername ?? person?.github_login ?? '';
            const s = String(raw || '').trim();
            if (s) return s;

            // If name itself looks like a GitHub username, allow it.
            const name = String(person?.name || '').trim();
            const looksLikeGitHubUsername = /^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,37}[a-zA-Z0-9])?$/.test(name);
            return looksLikeGitHubUsername ? name : '';
        }

        function getGitHubAvatarUrl(username, size = 64) {
            const u = String(username || '').trim();
            if (!u) return '';
            const s = Math.max(16, Math.min(256, Number(size) || 64));
            return `https://github.com/${encodeURIComponent(u)}.png?size=${s}`;
        }

        function getInitials(name) {
            const s = String(name || '').trim();
            if (!s) return '?';
            const parts = s.split(/\s+/).filter(Boolean);
            if (parts.length === 1) return parts[0].slice(0, 2).toUpperCase();
            return `${parts[0][0] || ''}${parts[1][0] || ''}`.toUpperCase() || '?';
        }

        function createInitialsAvatarEl(personName) {
            const el = document.createElement('span');
            el.className = 'person-avatar-fallback';
            el.textContent = getInitials(personName);
            el.setAttribute('aria-hidden', 'true');
            return el;
        }

        function createPersonAvatarEl(person) {
            const personId = String(person?.id || '').trim();
            const personName = person?.name ? String(person.name) : (personId || 'Person');
            const gh = getGitHubUsername(person);
            if (!gh) return createInitialsAvatarEl(personName);

            const img = document.createElement('img');
            img.className = 'person-avatar';
            img.loading = 'lazy';
            img.decoding = 'async';
            img.referrerPolicy = 'no-referrer';
            img.alt = `${personName} (GitHub avatar)`;
            img.src = getGitHubAvatarUrl(gh, 64);
            img.addEventListener('error', () => {
                if (img.dataset.fallbackApplied === '1') return;
                img.dataset.fallbackApplied = '1';
                img.replaceWith(createInitialsAvatarEl(personName));
            });
            return img;
        }

        function renderPersonDetails({ person, container }) {
            if (!person || !container) return;
            const personId = String(person?.id || '').trim();
            if (!personId) return;

            const skills = Array.isArray(person?.skills) ? person.skills : [];
            container.innerHTML = '';

            // Skills section (only skills present for this person)
            const skillsSection = document.createElement('div');
            skillsSection.className = 'person-section';
            const skillsTitle = document.createElement('div');
            skillsTitle.className = 'person-section-title';
            skillsTitle.textContent = 'Unlocked skills';
            skillsSection.appendChild(skillsTitle);

            const skillsList = document.createElement('div');
            skillsList.className = 'person-skill-list';

            const sorted = [...skills].sort((a, b) => {
                const da = String(a?.domain || '');
                const db = String(b?.domain || '');
                const sa = String(a?.skill || '');
                const sb = String(b?.skill || '');
                return da.localeCompare(db) || sa.localeCompare(sb);
            });

            const perSkillMetrics = personIdToSkillMetrics.get(personId) || new Map();
            sorted.forEach(rec => {
                const domainName = String(rec?.domain || '').trim();
                const skillName = String(rec?.skill || '').trim();
                if (!domainName || !skillName) return;

                const skillKey = makeSkillKey(domainName, skillName);
                const meta = skillKeyToMeta.get(skillKey);
                const total = meta?.subSkillNames?.size ?? 0;
                const metric = perSkillMetrics.get(skillKey) || { usage: 0, unlockedCount: 0 };
                const unlocked = Number(metric?.unlockedCount) || 0;
                const pct01 = total > 0 ? unlocked / total : 0;
                const usage = Number(metric?.usage) || 0;

                const row = document.createElement('div');
                row.className = 'person-skill-row';

                const main = document.createElement('div');
                main.className = 'person-skill-main';
                const name = document.createElement('div');
                name.className = 'person-skill-name';
                name.textContent = skillName;
                const sub = document.createElement('div');
                sub.className = 'person-skill-sub';
                sub.textContent = `${domainName} ‚Ä¢ Usage ${Math.round(usage)}`;
                main.appendChild(name);
                main.appendChild(sub);

                const stat = document.createElement('div');
                stat.className = 'person-skill-stat';
                stat.textContent = total > 0 ? `${unlocked}/${total} (${formatPercent01(pct01)})` : `${unlocked} (n/a)`;

                const bar = document.createElement('div');
                bar.className = 'person-skill-bar';
                const fill = document.createElement('div');
                fill.className = 'person-skill-bar-fill';
                fill.style.width = `${Math.round(Math.max(0, Math.min(1, pct01)) * 100)}%`;
                bar.appendChild(fill);

                row.appendChild(main);
                row.appendChild(stat);
                row.appendChild(bar);
                skillsList.appendChild(row);
            });

            if (skillsList.childElementCount === 0) {
                const empty = document.createElement('div');
                empty.className = 'person-empty';
                empty.textContent = 'No skills listed for this person.';
                skillsList.appendChild(empty);
            }

            skillsSection.appendChild(skillsList);
            container.appendChild(skillsSection);

            // AI recommendations section
            const recoSection = document.createElement('div');
            recoSection.className = 'person-section';
            const recoTitle = document.createElement('div');
            recoTitle.className = 'person-section-title';
            recoTitle.textContent = 'AI recommended skills (team)';
            recoSection.appendChild(recoTitle);

            // Use current selection as "team"
            recomputeSelectionAggregates();
            const selectedCount = selectedPersonIds?.size || 0;
            const recommendations = [];
            const totalPeople = selectedCount;

            const recoHint = document.createElement('div');
            recoHint.className = 'person-reco-hint';
            recoHint.textContent = selectedCount > 0
                ? `Computed from the ${selectedCount} people currently selected in People`
                : 'Select at least 1 person in People';
            recoSection.appendChild(recoHint);

            for (const [skillKey, meta] of skillKeyToMeta.entries()) {
                const total = meta?.subSkillNames?.size ?? 0;
                if (total <= 0) continue;
                if (selectedCount === 0) continue;

                const sel = getSelectionMetricsForSkillKey(skillKey);
                const haveRatio = sel.unlockedPeopleRatio;
                const usageAvg = sel.usageAvg;
                const completionAvg = selectedCount > 0 ? (sel.unlockedSum / (selectedCount * total)) : 0;
                if (completionAvg >= 1) continue; // fully unlocked for selected team
                if (usageAvg <= 0) continue; // no evidence it's being used

                // Recommend skills that are heavily used but not broadly adopted in the team.
                const score = (usageAvg / 100) * (1 - completionAvg);

                recommendations.push({
                    skillKey,
                    domainName: meta.domainName,
                    skillName: meta.skillName,
                    haveRatio,
                    haveCount: sel.unlockedPeopleCount,
                    completionAvg,
                    usageAvg,
                    score
                });
            }

            recommendations.sort((a, b) => (b.score - a.score) || (a.domainName.localeCompare(b.domainName)) || (a.skillName.localeCompare(b.skillName)));
            const top = recommendations.slice(0, 5);

            const recoList = document.createElement('div');
            recoList.className = 'person-reco-list';
            if (selectedCount === 0) {
                const empty = document.createElement('div');
                empty.className = 'person-empty';
                empty.textContent = 'Select at least 1 person to compute team recommendations.';
                recoList.appendChild(empty);
            } else if (top.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'person-empty';
                empty.textContent = 'No clear team skill gaps found (or missing taxonomy/people data).';
                recoList.appendChild(empty);
            } else {
                top.forEach(r => {
                    const row = document.createElement('div');
                    row.className = 'person-reco-row';

                    const left = document.createElement('div');
                    left.className = 'person-reco-main';
                    const name = document.createElement('div');
                    name.className = 'person-reco-name';
                    name.textContent = r.skillName;
                    const sub = document.createElement('div');
                    sub.className = 'person-reco-sub';
                    const teamPct = formatPercent01(r.haveRatio);
                    const haveText = totalPeople > 0 ? `${r.haveCount}/${totalPeople} (${teamPct})` : `${teamPct}`;
                    const completionText = formatPercent01(r.completionAvg);
                    sub.textContent = `${r.domainName} ‚Ä¢ Team adoption ${haveText} ‚Ä¢ Team completion ${completionText} ‚Ä¢ Avg usage ${Math.round(r.usageAvg)}`;
                    left.appendChild(name);
                    left.appendChild(sub);

                    row.appendChild(left);
                    const bar = document.createElement('div');
                    bar.className = 'person-skill-bar';
                    const fill = document.createElement('div');
                    fill.className = 'person-skill-bar-fill';
                    fill.style.width = `${Math.round(Math.max(0, Math.min(1, Number(r.completionAvg) || 0)) * 100)}%`;
                    bar.appendChild(fill);
                    row.appendChild(bar);

                    const usageRounded = Math.round(Number(r.usageAvg) || 0);
                    const havePctInt = Math.round(Math.max(0, Math.min(1, Number(r.haveRatio) || 0)) * 100);
                    const completionPctInt = Math.round(Math.max(0, Math.min(1, Number(r.completionAvg) || 0)) * 100);
                    const gapPctInt = Math.max(0, 100 - completionPctInt);
                    const usageLevel = usageRounded >= 60 ? 'High' : usageRounded >= 35 ? 'Medium' : 'Low';

                    const reason = document.createElement('div');
                    reason.className = 'person-reco-reason';
                    reason.textContent = [
                        'Reasoning:',
                        `- Usage ${usageRounded} (${usageLevel}) ‚Üí likely relevant to current team work`,
                        `- Completion gap ${gapPctInt}% (current ${completionPctInt}%) ‚Üí worth closing the gap`,
                        `- Adoption ${havePctInt}% (${r.haveCount}/${totalPeople} people) ‚Üí reduce single‚Äëpoint knowledge risk`
                    ].join('\n');
                    row.appendChild(reason);
                    recoList.appendChild(row);
                });
            }

            recoSection.appendChild(recoList);
            container.appendChild(recoSection);
        }

        function renderTopLists() {
            const mostList = document.getElementById('topMostList');
            const leastList = document.getElementById('topLeastList');
            const mostEmpty = document.getElementById('topMostEmpty');
            const leastEmpty = document.getElementById('topLeastEmpty');

            if (!mostList || !leastList || !mostEmpty || !leastEmpty) return;

            // Clear
            mostList.innerHTML = '';
            leastList.innerHTML = '';

            const selectedCount = selectedPersonIds?.size || 0;
            if (!isPeopleModeEnabled()) {
                const msg = 'Multi-person mode is not enabled (people.json not loaded).';
                mostEmpty.textContent = msg;
                leastEmpty.textContent = msg;
                mostEmpty.style.display = 'block';
                leastEmpty.style.display = 'block';
                return;
            }

            if (selectedCount === 0) {
                const msg = 'Select at least one person to compute proficient skills.';
                mostEmpty.textContent = msg;
                leastEmpty.textContent = msg;
                mostEmpty.style.display = 'block';
                leastEmpty.style.display = 'block';
                return;
            }

            mostEmpty.style.display = 'none';
            leastEmpty.style.display = 'none';

            // Ensure aggregates are current
            recomputeSelectionAggregates();

            const entries = [];
            for (const [skillKey, meta] of skillKeyToMeta.entries()) {
                const agg = selectionAggBySkillKey.get(skillKey);
                const usageSum = Number(agg?.usageSum) || 0;
                const usageAvg = usageSum / selectedCount; // missing skill counts as 0
                entries.push({
                    skillKey,
                    domainName: meta.domainName,
                    skillName: meta.skillName,
                    usageAvg
                });
            }

            const tieBreak = (a, b) => {
                const ka = `${a.domainName}::${a.skillName}`;
                const kb = `${b.domainName}::${b.skillName}`;
                return ka.localeCompare(kb);
            };

            const most = [...entries]
                .sort((a, b) => (b.usageAvg - a.usageAvg) || tieBreak(a, b))
                .slice(0, 5);
            const least = [...entries]
                .sort((a, b) => (a.usageAvg - b.usageAvg) || tieBreak(a, b))
                .slice(0, 5);

            const renderList = (ul, items) => {
                items.forEach(it => {
                    const li = document.createElement('li');
                    li.className = 'toplist-item';

                    const left = document.createElement('div');
                    const skill = document.createElement('div');
                    skill.className = 'toplist-skill';
                    skill.textContent = it.skillName;
                    const domain = document.createElement('span');
                    domain.className = 'toplist-domain';
                    domain.textContent = it.domainName;
                    left.appendChild(skill);
                    left.appendChild(domain);

                    const stat = document.createElement('div');
                    stat.className = 'toplist-stat';
                    const avg = Math.round(it.usageAvg);
                    stat.textContent = `${avg}`;

                    li.appendChild(left);
                    li.appendChild(stat);
                    ul.appendChild(li);
                });
            };

            renderList(mostList, most);
            renderList(leastList, least);
        }

        function applySelectionToCurrentView() {
            const svg = d3.select('#chart');
            const cells = svg.selectAll('.skill-cell');
            if (cells.empty()) return;

            if (!isPeopleModeEnabled()) {
                // Single-taxonomy fallback: color/opacity from built-in values.
                cells
                    .attr('fill', d => {
                        const domainName = d?.data?.__domain || (d?.parent ? d.parent.data.name : 'Unknown');
                        const colorScheme = domainColorSchemes[domainName] || d3.interpolateRainbow;
                        return colorScheme(usageTGlobal(getUsageValue(d?.data)));
                    })
                    .attr('opacity', 0.9)
                    .attr('stroke-width', 1.5);
                renderTopLists();
                return;
            }

            recomputeSelectionAggregates();

            cells
                .attr('fill', d => {
                    const domainName = d?.data?.__domain || (d?.parent ? d.parent.data.name : 'Unknown');
                    const skillKey = d?.data?.__skillKey || makeSkillKey(domainName, d?.data?.name || '');
                    const metrics = getSelectionMetricsForSkillKey(skillKey);
                    const colorScheme = domainColorSchemes[domainName] || d3.interpolateRainbow;
                    return colorScheme(usageTGlobal(metrics.usageAvg));
                })
                .attr('opacity', d => {
                    const domainName = d?.data?.__domain || (d?.parent ? d.parent.data.name : 'Unknown');
                    const skillKey = d?.data?.__skillKey || makeSkillKey(domainName, d?.data?.name || '');
                    const metrics = getSelectionMetricsForSkillKey(skillKey);
                    if (metrics.selectedCount === 0) return 0.15;
                    return 0.15 + 0.85 * metrics.unlockedPeopleRatio;
                })
                .attr('stroke-width', d => {
                    const domainName = d?.data?.__domain || (d?.parent ? d.parent.data.name : 'Unknown');
                    const skillKey = d?.data?.__skillKey || makeSkillKey(domainName, d?.data?.name || '');
                    const metrics = getSelectionMetricsForSkillKey(skillKey);
                    if (metrics.selectedCount === 0) return 1.5;
                    return 1.2 + 1.8 * metrics.unlockedPeopleRatio;
                });

            renderTopLists();
        }

        function initPeopleUI(people) {
            const panel = document.getElementById('peoplePanel');
            const list = document.getElementById('peopleList');
            const selectAllBtn = document.getElementById('selectAllPeopleBtn');
            const clearBtn = document.getElementById('clearPeopleBtn');
            const searchInput = document.getElementById('peopleSearch');
            const detailsBackdrop = document.getElementById('peopleDetailsBackdrop');
            const detailsTitle = document.getElementById('peopleDetailsTitle');
            const detailsBody = document.getElementById('peopleDetailsBody');
            const detailsCloseBtn = document.getElementById('peopleDetailsCloseBtn');

            if (!panel || !list || !selectAllBtn || !clearBtn || !detailsBackdrop || !detailsTitle || !detailsBody || !detailsCloseBtn) return;

            const persons = Array.isArray(people) ? people : [];
            if (persons.length === 0) {
                panel.style.display = 'none';
                return;
            }

            panel.style.display = 'block';
            list.innerHTML = '';
            if (searchInput) searchInput.value = '';

            // Default: all selected
            selectedPersonIds = new Set(persons.map(p => String(p?.id || '').trim()).filter(Boolean));
            updatePeopleCountLabel();

            const closeDetails = () => {
                if (detailsBackdrop.dataset.open !== '1') return;
                detailsBackdrop.dataset.open = '0';
                detailsBackdrop.setAttribute('aria-hidden', 'true');
                document.body.classList.remove('people-details-open');
            };

            const openDetails = (person) => {
                if (!person) return;
                const personId = String(person?.id || '').trim();
                const personName = person?.name ? String(person.name) : personId;
                detailsTitle.textContent = personName || 'Details';
                detailsBody.innerHTML = '';
                renderPersonDetails({ person, container: detailsBody });
                detailsBackdrop.dataset.open = '1';
                detailsBackdrop.setAttribute('aria-hidden', 'false');
                document.body.classList.add('people-details-open');
            };

            if (detailsBackdrop.dataset.bound !== '1') {
                detailsBackdrop.dataset.bound = '1';
                detailsCloseBtn.addEventListener('click', closeDetails);
                detailsBackdrop.addEventListener('click', (e) => {
                    if (e.target === detailsBackdrop) closeDetails();
                });
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') closeDetails();
                });
            }

            const fragment = document.createDocumentFragment();

            persons.forEach(person => {
                const personId = String(person?.id || '').trim();
                if (!personId) return;
                const personName = person?.name ? String(person.name) : personId;

                const item = document.createElement('div');
                item.className = 'person-item';
                item.dataset.personId = personId;
                item.dataset.searchText = `${personName} ${personId}`.toLowerCase();

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'person-checkbox';
                checkbox.checked = true;
                checkbox.id = `person-check-${personId}`;
                checkbox.setAttribute('aria-label', `Select ${personName}`);
                checkbox.addEventListener('change', () => {
                    if (checkbox.checked) selectedPersonIds.add(personId);
                    else selectedPersonIds.delete(personId);
                    updatePeopleCountLabel();
                    applySelectionToCurrentView();
                });

                const label = document.createElement('label');
                label.className = 'person-name';
                label.htmlFor = checkbox.id;
                label.textContent = personName;

                const avatar = createPersonAvatarEl(person);

                const detailsBtn = document.createElement('button');
                detailsBtn.type = 'button';
                detailsBtn.className = 'person-details-btn';
                detailsBtn.textContent = 'Details';
                detailsBtn.setAttribute('aria-label', `View details for ${personName}`);
                detailsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    openDetails(person);
                });

                // Click on row toggles the checkbox (avoid double-toggle when clicking the checkbox/label)
                item.addEventListener('click', (e) => {
                    const t = e.target;
                    if (t === checkbox) return;
                    if (t && t.tagName === 'LABEL') return;
                    if (t && t.tagName === 'BUTTON') return;
                    checkbox.checked = !checkbox.checked;
                    checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                });

                item.appendChild(checkbox);
                item.appendChild(avatar);
                item.appendChild(label);
                item.appendChild(detailsBtn);
                fragment.appendChild(item);
            });

            list.appendChild(fragment);

            if (searchInput) {
                searchInput.oninput = () => {
                    const q = String(searchInput.value || '').trim().toLowerCase();
                    list.querySelectorAll('.person-item').forEach(item => {
                        const txt = String(item?.dataset?.searchText || '');
                        item.style.display = q === '' || txt.includes(q) ? '' : 'none';
                    });
                };
            }

            selectAllBtn.onclick = () => {
                selectedPersonIds = new Set(persons.map(p => String(p?.id || '').trim()).filter(Boolean));
                list.querySelectorAll('.person-item .person-checkbox').forEach(cb => cb.checked = true);
                updatePeopleCountLabel();
                applySelectionToCurrentView();
            };

            clearBtn.onclick = () => {
                selectedPersonIds = new Set();
                list.querySelectorAll('.person-item .person-checkbox').forEach(cb => cb.checked = false);
                updatePeopleCountLabel();
                applySelectionToCurrentView();
            };
        }

        async function initApp() {
            taxonomyData = cloneObject(baseTaxonomy);
            currentData = taxonomyData;
            history = [];

            // Try multi-person mode first
            try {
                const resp = await fetch('./people.json', { cache: 'no-store' });
                if (!resp.ok) throw new Error(`Failed to load people.json (${resp.status})`);
                peopleData = await resp.json();
                const persons = Array.isArray(peopleData?.people) ? peopleData.people : [];

                applyPeopleUnionToTaxonomy(taxonomyData, persons);
                annotateAndIndexTaxonomy(taxonomyData);
                buildPeopleMetrics(persons);
                computeTeamSkillStats(persons);
                initPeopleUI(persons);
            } catch (err) {
                // Fallback to single-taxonomy mode if people.json can't be loaded
                console.warn('Multi-person mode disabled:', err);
                peopleData = null;
                selectedPersonIds = new Set();
                const panel = document.getElementById('peoplePanel');
                if (panel) panel.style.display = 'none';

                annotateAndIndexTaxonomy(taxonomyData);

                // Use the built-in unlocked/usage values for layout + coloring
                const usageValues = [];
                for (const meta of skillKeyToMeta.values()) {
                    usageValues.push(0);
                }
                usageTGlobal = createGlobalUsageIntensityScale(taxonomyData);
                layoutWeightBySkillKey = new Map();
                layoutUnlockedSumBySkillKey = new Map();

                // Derive weights from the taxonomy's unlocked sub-skills
                const domains = Array.isArray(taxonomyData?.children) ? taxonomyData.children : [];
                domains.forEach(domain => {
                    const domainName = domain?.name;
                    const skills = Array.isArray(domain?.children) ? domain.children : [];
                    skills.forEach(skill => {
                        if (!domainName || !skill?.name) return;
                        const key = makeSkillKey(domainName, skill.name);
                        const { unlocked } = getSubSkillCounts(skill);
                        layoutUnlockedSumBySkillKey.set(key, unlocked);
                        layoutWeightBySkillKey.set(key, Math.max(0.001, unlocked));
                    });
                });
                layoutCache.clear();
            }

            renderChart(currentData);
        }

        function getViewKey(data) {
            const rootName = taxonomyData?.name || 'Tech Skills';
            if (!data || !data.name) return 'overview';
            return data.name === rootName ? 'overview' : `domain::${data.name}`;
        }

        function getOrComputeLayout(data) {
            const key = getViewKey(data);
            if (layoutCache.has(key)) return layoutCache.get(key);
            if (typeof d3.voronoiTreemap === 'undefined') return null;

            const circlePolygon = createCirclePolygon(radius, 64);

            const root = d3.hierarchy(data)
                .sum(d => {
                    if (d && Array.isArray(d.children)) return 0;
                    const domainName = d?.__domain || '';
                    const skillKey = d?.__skillKey || makeSkillKey(domainName, d?.name || '');
                    const w = layoutWeightBySkillKey.get(skillKey);
                    if (Number.isFinite(w)) return w;
                    return Math.max(0.001, getSubSkillCounts(d).unlocked);
                })
                .sort((a, b) => (b.value || 0) - (a.value || 0));

            const voronoiTreemap = d3.voronoiTreemap()
                .clip(circlePolygon)
                .convergenceRatio(0.001)
                .maxIterationCount(100)
                .minWeightRatio(0.001);

            voronoiTreemap(root);

            const layout = {
                key,
                root,
                isWorldView: key === 'overview',
                leaves: root.leaves(),
                domains: root.children || []
            };

            layoutCache.set(key, layout);
            return layout;
        }

        function renderChart(data) {
            d3.select('#chart').selectAll('*').remove();

            const svg = d3.select('#chart')
                .attr('width', width)
                .attr('height', height);

            const centerX = width / 2;
            const centerY = height / 2;

            const viewKey = getViewKey(data);
            const isWorldView = viewKey === 'overview';
            const layout = (typeof d3.voronoiTreemap !== 'undefined') ? getOrComputeLayout(data) : null;
            const root = layout?.root || null;

            // Draw outer circle border (removing dark border per request)
            svg.append('circle')
                .attr('cx', centerX)
                .attr('cy', centerY)
                .attr('r', radius)
                .attr('fill', 'none')
                .attr('stroke', 'none')
                .attr('stroke-width', 0);

            // Create circular clip path
            const defs = svg.append('defs');
            defs.append('clipPath')
                .attr('id', 'circle-clip')
                .append('circle')
                .attr('cx', 0)
                .attr('cy', 0)
                .attr('r', radius);

            const g = svg.append('g')
                .attr('transform', `translate(${centerX},${centerY})`)
                .attr('clip-path', 'url(#circle-clip)');

            if (isWorldView && layout) {
                // ========== Use d3-voronoi-treemap for weighted nested Voronoi ==========

                const allCountries = layout.leaves;
                const continents = layout.domains;

                // Draw skill cells
                g.selectAll('.skill-cell')
                    .data(allCountries)
                    .join('path')
                    .attr('class', 'skill-cell')
                    .attr('d', d => d.polygon ? "M" + d.polygon.join("L") + "Z" : null)
                    .attr('fill', '#ddd')
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 1.5)
                    .attr('opacity', 0.9)
                    .style('cursor', 'pointer')
                    .on('mouseover', function (event, d) {
                        d3.select(this)
                            .attr('opacity', 1)
                            .attr('stroke-width', 3);

                        const tooltip = document.getElementById('tooltip');
                        tooltip.style.display = 'block';

                        const totalValue = root?.value || 1;
                        const percentage = ((d.value || 0) / totalValue * 100).toFixed(1);
                        const domainName = d.parent ? d.parent.data.name : '';
                        const skillKey = d?.data?.__skillKey || makeSkillKey(domainName, d?.data?.name || '');

                        if (isPeopleModeEnabled()) {
                            const teamUnlocked = layoutUnlockedSumBySkillKey.get(skillKey) ?? 0;
                            const metrics = getSelectionMetricsForSkillKey(skillKey);
                            const usageAvg = Math.round(metrics.usageAvg);
                            const ratioPct = Math.round(metrics.unlockedPeopleRatio * 100);
                            const selectedLine = metrics.selectedCount > 0
                                ? `Selected: ${metrics.selectedCount} ‚Ä¢ Have skill: ${metrics.unlockedPeopleCount}/${metrics.selectedCount} (${ratioPct}%)`
                                : 'Selected: 0 (no people selected)';

                            tooltip.innerHTML = `
                                <strong>${d.data.name} (${domainName})</strong>
                                <div>Team unlocked (sum): ${teamUnlocked}</div>
                                <div>${selectedLine}</div>
                                <div>Avg usage (selected): ${usageAvg}</div>
                                <div>% of Team (layout weight): ${percentage}%</div>
                                <div style="margin-top: 4px; font-style: italic;">Missing skills count as 0 ‚Ä¢ Click to view ${domainName} ‚Üí</div>
                            `;
                        } else {
                            const { unlocked, total } = getSubSkillCounts(d.data);
                            const usage = getUsageValue(d.data);
                            tooltip.innerHTML = `
                                <strong>${d.data.name} (${domainName})</strong>
                                <div>Unlocked sub-skills: ${unlocked}/${total}</div>
                                <div>Usage frequency: ${usage}</div>
                                <div>% of Total (unlocked): ${percentage}%</div>
                                <div style="margin-top: 4px; font-style: italic;">Click to view ${domainName} skills ‚Üí</div>
                            `;
                        }

                        positionTooltip(event, tooltip);
                    })
                    .on('mousemove', function (event, d) {
                        const tooltip = document.getElementById('tooltip');
                        if (tooltip?.style?.display === 'block') {
                            positionTooltip(event, tooltip);
                        }
                    })
                    .on('mouseout', function () {
                        const tooltip = document.getElementById('tooltip');
                        tooltip.style.display = 'none';
                        applySelectionToCurrentView();
                    })
                    .on('click', function (event, d) {
                        event.stopPropagation();
                        if (d.parent && d.parent.data.name !== 'Tech Skills') {
                            drillDown(d.parent.data);
                        }
                    });

                // Draw domain borders (removed per request)
                g.selectAll('.domain-border')
                    .data(continents)
                    .join('path')
                    .attr('class', 'domain-border')
                    .attr('d', d => d.polygon ? "M" + d.polygon.join("L") + "Z" : null)
                    .attr('fill', 'none')
                    .attr('stroke', 'none')
                    .attr('stroke-width', 0)
                    .style('pointer-events', 'none');

                // Add skill labels
                g.selectAll('.skill-label')
                    .data(allCountries)
                    .join('text')
                    .attr('class', 'skill-label')
                    .attr('x', d => d.polygon ? d3.polygonCentroid(d.polygon)[0] : 0)
                    .attr('y', d => d.polygon ? d3.polygonCentroid(d.polygon)[1] : 0)
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'middle')
                    .attr('fill', '#fff')
                    .attr('font-size', d => {
                        if (!d.polygon) return '10px';
                        const area = Math.abs(d3.polygonArea(d.polygon));
                        return Math.max(8, Math.min(18, Math.sqrt(area) / 10)) + 'px';
                    })
                    .attr('font-weight', 'bold')
                    .style('pointer-events', 'none')
                    .text(d => {
                        if (!d.polygon) return '';
                        const area = Math.abs(d3.polygonArea(d.polygon));
                        const name = d.data.name;

                        if (area > 8000) return name;
                        if (area > 4000) return name.length > 10 ? name.substring(0, 10) : name;
                        if (area > 2000) return name.length > 6 ? name.substring(0, 6) : name;
                        return '';
                    });

            } else if (isWorldView) {
                // Library not loaded, show error message
                g.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#666')
                    .attr('font-size', '14px')
                    .text('‚ö†Ô∏è d3-voronoi-treemap layout is unavailable');
            } else {
                // ========== Domain view: only show skills in that domain ==========
                if (layout) {
                    const skills = layout.leaves;
                    const colorScheme = domainColorSchemes[data.name] || d3.interpolateRainbow;

                    g.selectAll('.skill-cell')
                        .data(skills)
                        .join('path')
                        .attr('class', 'skill-cell')
                        .attr('d', d => d.polygon ? "M" + d.polygon.join("L") + "Z" : null)
                        .attr('fill', '#ddd')
                        .attr('stroke', '#fff')
                        .attr('stroke-width', 2)
                        .attr('opacity', 0.9)
                        .style('cursor', 'default')
                        .on('click', function (event) {
                            // prevent "click anywhere to go back" from firing when clicking a skill
                            event.stopPropagation();
                        })
                        .on('mouseover', function (event, d) {
                            d3.select(this)
                                .attr('opacity', 1)
                                .attr('stroke-width', 3);

                            const tooltip = document.getElementById('tooltip');
                            tooltip.style.display = 'block';

                            const percentage = ((d.value || 0) / (root?.value || 1) * 100).toFixed(1);
                            const domainName = data?.name || '';
                            const skillKey = d?.data?.__skillKey || makeSkillKey(domainName, d?.data?.name || '');

                            if (isPeopleModeEnabled()) {
                                const teamUnlocked = layoutUnlockedSumBySkillKey.get(skillKey) ?? 0;
                                const metrics = getSelectionMetricsForSkillKey(skillKey);
                                const usageAvg = Math.round(metrics.usageAvg);
                                const ratioPct = Math.round(metrics.unlockedPeopleRatio * 100);
                                const selectedLine = metrics.selectedCount > 0
                                    ? `Selected: ${metrics.selectedCount} ‚Ä¢ Have skill: ${metrics.unlockedPeopleCount}/${metrics.selectedCount} (${ratioPct}%)`
                                    : 'Selected: 0 (no people selected)';

                                tooltip.innerHTML = `
                                    <strong>${d.data.name}</strong>
                                    <div>Team unlocked (sum): ${teamUnlocked}</div>
                                    <div>${selectedLine}</div>
                                    <div>Avg usage (selected): ${usageAvg}</div>
                                    <div>% of ${domainName} (layout weight): ${percentage}%</div>
                                    <div style="margin-top: 4px; font-style: italic;">Missing skills count as 0</div>
                                `;
                            } else {
                                const { unlocked, total } = getSubSkillCounts(d.data);
                                const usage = getUsageValue(d.data);
                                tooltip.innerHTML = `
                                    <strong>${d.data.name}</strong>
                                    <div>Unlocked sub-skills: ${unlocked}/${total}</div>
                                    <div>Usage frequency: ${usage}</div>
                                    <div>% of ${domainName} (unlocked): ${percentage}%</div>
                                `;
                            }

                            positionTooltip(event, tooltip);
                        })
                        .on('mousemove', function (event, d) {
                            const tooltip = document.getElementById('tooltip');
                            if (tooltip?.style?.display === 'block') {
                                positionTooltip(event, tooltip);
                            }
                        })
                        .on('mouseout', function () {
                            const tooltip = document.getElementById('tooltip');
                            tooltip.style.display = 'none';
                            applySelectionToCurrentView();
                        });

                    g.selectAll('.skill-label')
                        .data(skills)
                        .join('text')
                        .attr('class', 'skill-label')
                        .attr('x', d => d.polygon ? d3.polygonCentroid(d.polygon)[0] : 0)
                        .attr('y', d => d.polygon ? d3.polygonCentroid(d.polygon)[1] : 0)
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'middle')
                        .attr('fill', '#fff')
                        .attr('font-size', d => {
                            if (!d.polygon) return '10px';
                            const area = Math.abs(d3.polygonArea(d.polygon));
                            return Math.max(10, Math.min(22, Math.sqrt(area) / 10)) + 'px';
                        })
                        .attr('font-weight', 'bold')
                        .style('pointer-events', 'none')
                        .text(d => {
                            if (!d.polygon) return '';
                            const area = Math.abs(d3.polygonArea(d.polygon));
                            const name = d.data.name;
                            if (area > 7000) return name;
                            if (area > 3500) return name.length > 10 ? name.substring(0, 10) : name;
                            if (area > 1800) return name.length > 6 ? name.substring(0, 6) : name;
                            return '';
                        });
                } else {
                    // Fallback: pack + delaunay (not strictly area-proportional)
                    const fallbackRoot = d3.hierarchy(data)
                        .sum(d => {
                            if (d && Array.isArray(d.children)) return 0;
                            return Math.max(0.001, getSubSkillCounts(d).unlocked);
                        })
                        .sort((a, b) => (b.value || 0) - (a.value || 0));

                    const countries = fallbackRoot.children || [];

                    const pack = d3.pack()
                        .size([radius * 2, radius * 2])
                        .padding(3);
                    pack(fallbackRoot);

                    const sites = countries.map(d => [d.x - radius, d.y - radius]);
                    const voronoi = d3.Delaunay.from(sites).voronoi([-radius, -radius, radius, radius]);

                    const colorScheme = domainColorSchemes[data.name] || d3.interpolateRainbow;

                    g.selectAll('path')
                        .data(countries)
                        .join('path')
                        .attr('d', (d, i) => voronoi.renderCell(i))
                        .attr('fill', d => colorScheme(usageTGlobal(getUsageValue(d.data))))
                        .attr('stroke', '#fff')
                        .attr('stroke-width', 2)
                        .attr('opacity', 0.9)
                        .style('cursor', 'default')
                        .on('click', function (event) {
                            event.stopPropagation();
                        })
                        .on('mouseover', function (event, d) {
                            d3.select(this)
                                .attr('opacity', 1)
                                .attr('stroke-width', 3);

                            const tooltip = document.getElementById('tooltip');
                            tooltip.style.display = 'block';

                            const percentage = ((d.value || 0) / (fallbackRoot.value || 1) * 100).toFixed(1);
                            const { unlocked, total } = getSubSkillCounts(d.data);
                            const usage = getUsageValue(d.data);

                            tooltip.innerHTML = `
                                <strong>${d.data.name}</strong>
                                <div>Unlocked sub-skills: ${unlocked}/${total}</div>
                                <div>Usage frequency: ${usage}</div>
                                <div>% of ${data.name} (unlocked): ${percentage}%</div>
                            `;

                            positionTooltip(event, tooltip);
                        })
                        .on('mousemove', function (event, d) {
                            const tooltip = document.getElementById('tooltip');
                            if (tooltip?.style?.display === 'block') {
                                positionTooltip(event, tooltip);
                            }
                        })
                        .on('mouseout', function () {
                            d3.select(this)
                                .attr('opacity', 0.9)
                                .attr('stroke-width', 2);
                            const tooltip = document.getElementById('tooltip');
                            tooltip.style.display = 'none';
                        });

                    g.selectAll('text')
                        .data(countries)
                        .join('text')
                        .attr('x', d => d.x - radius)
                        .attr('y', d => d.y - radius)
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'middle')
                        .attr('fill', '#fff')
                        .attr('font-size', d => {
                            const area = Math.PI * Math.pow(d.r || 0, 2);
                            return Math.max(10, Math.min(24, Math.sqrt(area) / 6)) + 'px';
                        })
                        .attr('font-weight', 'bold')
                        .style('pointer-events', 'none')
                        .text(d => d.data.name);
                }
            }

            // Add outer ring domain labels in overview
            if (isWorldView) {
                const continents = root.children || [];

                continents.forEach(continent => {
                    const domainName = String(continent?.data?.name || '');
                    const colorScheme = domainColorSchemes[domainName] || d3.interpolateRainbow;
                    const badgeFill = colorScheme(0.75);

                    // Use polygon centroid to calculate angle
                    const centroid = continent.polygon ? d3.polygonCentroid(continent.polygon) : [0, 0];
                    const angle = Math.atan2(centroid[1], centroid[0]);
                    const labelRadius = radius + 50;
                    const labelX = centerX + Math.cos(angle) * labelRadius;
                    const labelY = centerY + Math.sin(angle) * labelRadius;

                    const textElement = svg.append('text')
                        .attr('class', 'domain-label')
                        .attr('x', labelX)
                        .attr('y', labelY)
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'middle')
                        .attr('fill', '#fff')
                        .attr('font-size', '15px')
                        .attr('font-weight', 'bold')
                        .style('pointer-events', 'none')
                        .text(domainName);

                    const bbox = textElement.node().getBBox();

                    svg.insert('rect', () => textElement.node())
                        .attr('class', 'domain-badge')
                        .attr('x', bbox.x - 10)
                        .attr('y', bbox.y - 6)
                        .attr('width', bbox.width + 20)
                        .attr('height', bbox.height + 12)
                        .attr('fill', badgeFill)
                        .attr('opacity', 0.96)
                        .attr('rx', 10)
                        .attr('ry', 10)
                        .attr('stroke', 'none')
                        .attr('stroke-width', 0)
                        .style('filter', 'drop-shadow(0px 6px 10px rgba(0, 0, 0, 0.18))')
                        .style('pointer-events', 'none');
                });
            }

            svg.on('click', () => {
                if (history.length > 0) goBack();
            });

            // Apply selection-driven styling (method 2)
            applySelectionToCurrentView();

            updateControls();
        }

        // Clip polygon to another polygon (simplified Sutherland-Hodgman algorithm)
        function clipToPolygon(subject, clip) {
            if (!subject || !clip || subject.length < 3 || clip.length < 3) return subject;

            let output = subject;

            for (let i = 0; i < clip.length; i++) {
                if (output.length === 0) return [];

                const input = output;
                output = [];

                const edgeStart = clip[i];
                const edgeEnd = clip[(i + 1) % clip.length];

                for (let j = 0; j < input.length; j++) {
                    const current = input[j];
                    const next = input[(j + 1) % input.length];

                    const currentInside = isLeft(edgeStart, edgeEnd, current);
                    const nextInside = isLeft(edgeStart, edgeEnd, next);

                    if (currentInside) {
                        output.push(current);
                        if (!nextInside) {
                            const intersection = lineIntersection(edgeStart, edgeEnd, current, next);
                            if (intersection) output.push(intersection);
                        }
                    } else if (nextInside) {
                        const intersection = lineIntersection(edgeStart, edgeEnd, current, next);
                        if (intersection) output.push(intersection);
                    }
                }
            }

            return output.length >= 3 ? output : subject;
        }

        function isLeft(a, b, c) {
            return ((b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])) >= 0;
        }

        function lineIntersection(p1, p2, p3, p4) {
            const d = (p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0]);
            if (Math.abs(d) < 1e-10) return null;

            const t = ((p1[0] - p3[0]) * (p3[1] - p4[1]) - (p1[1] - p3[1]) * (p3[0] - p4[0])) / d;

            return [
                p1[0] + t * (p2[0] - p1[0]),
                p1[1] + t * (p2[1] - p1[1])
            ];
        }

        function drillDown(data) {
            history.push(currentData);
            currentData = data;
            renderChart(currentData);
        }

        function goBack() {
            if (history.length > 0) {
                currentData = history.pop();
                renderChart(currentData);
            }
        }

        function reset() {
            currentData = taxonomyData;
            history = [];
            renderChart(currentData);
        }

        function updateControls() {
            const controls = document.getElementById('controls');
            const breadcrumb = document.getElementById('breadcrumb');
            const mainTitle = document.getElementById('mainTitle');
            const subtitle = document.getElementById('subtitle');

            if (currentData !== taxonomyData || history.length > 0) {
                controls.style.display = 'flex';
                breadcrumb.textContent = currentData !== taxonomyData ? `Current: ${currentData.name}` : '';

                if (currentData.name !== "Tech Skills") {
                    mainTitle.textContent = `${getFlagEmoji(currentData.name)} ${currentData.name} Skills`;
                    subtitle.textContent = 'Click empty space to return to overview';
                } else {
                    mainTitle.textContent = 'üíª Programming Skills Map';
                    subtitle.textContent = 'Skills grouped by domain';
                }
            } else {
                controls.style.display = 'none';
                mainTitle.textContent = 'üíª Programming Skills Map';
                subtitle.textContent = 'Skills grouped by domain - roadmap.sh-style visualization';
            }
        }

        function getFlagEmoji(domainName) {
            const emojiMap = {
                'Frontend': 'üé®',
                'Backend': '‚öôÔ∏è',
                'DevOps': 'üöÄ',
                'Mobile': 'üì±'
            };
            return emojiMap[domainName] || 'üíª';
        }

        initApp();
    </script>
</body>

</html>